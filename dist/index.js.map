{"version":3,"sources":["../src/client.ts","../src/base.ts","../src/utils.ts","../src/environment.ts","../src/interactions.ts","../src/post.ts","../src/index.ts"],"sourcesContent":["import { type Client, elizaLogger, type IAgentRuntime, type Plugin } from \"@elizaos/core\";\nimport { ClientBase } from \"./base.ts\";\nimport { validateTwitterConfig, type TwitterConfig } from \"./environment.ts\";\nimport { TwitterInteractionClient } from \"./interactions.ts\";\nimport { TwitterPostClient } from \"./post.ts\";\nimport { TwitterSearchClient } from \"./search.ts\";\n// import { TwitterSpaceClient } from \"./spaces.ts\";\n\n/**\n * A manager that orchestrates all specialized Twitter logic:\n * - client: base operations (login, timeline caching, etc.)\n * - post: autonomous posting logic\n * - search: searching tweets / replying logic\n * - interaction: handling mentions, replies\n * - space: launching and managing Twitter Spaces (optional)\n */\nclass TwitterManager {\n    client: ClientBase;\n    post: TwitterPostClient;\n    // search: TwitterSearchClient;\n    interaction: TwitterInteractionClient;\n    // space?: TwitterSpaceClient;\n\n    constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\n        // Pass twitterConfig to the base client\n        this.client = new ClientBase(runtime, twitterConfig);\n\n        // Posting logic\n        this.post = new TwitterPostClient(this.client, runtime);\n\n        // TODO: #TWITTER-V2-003 - Reimplement search logic using Twitter API v2\n        // Optional search logic (enabled if TWITTER_SEARCH_ENABLE is true)\n        // if (twitterConfig.TWITTER_SEARCH_ENABLE) {\n        //     this.search = new TwitterSearchClient(this.client, runtime);\n        // }\n\n        // Mentions and interactions\n        this.interaction = new TwitterInteractionClient(this.client, runtime);\n\n        // TODO: #TWITTER-V2-004 - Reimplement spaces logic using Twitter API v2\n        // Optional Spaces logic (enabled if TWITTER_SPACES_ENABLE is true)\n        // if (twitterConfig.TWITTER_SPACES_ENABLE) {\n            // this.space = new TwitterSpaceClient(this.client, runtime);\n        // }\n    }\n\n    async stop() {\n        elizaLogger.warn(\"Twitter client does not support stopping yet\");\n    }\n}\n\nexport const TwitterClientInterface: Client = {\n    name: 'twitter',\n    async start(runtime: IAgentRuntime) {\n        const twitterConfig: TwitterConfig =\n            await validateTwitterConfig(runtime);\n\n        elizaLogger.log(\"Twitter client started\");\n\n        const manager = new TwitterManager(runtime, twitterConfig);\n\n        // Initialize login/session\n        await manager.client.init();\n\n        // Start the posting loop\n        await manager.post.start();\n\n        // TODO: #TWITTER-V2-003 - Reimplement search logic using Twitter API v2\n        // // Start the search logic if it exists\n        // if (manager.search) {\n        //     await manager.search.start();\n        // }\n\n        // Start interactions (mentions, replies)\n        await manager.interaction.start();\n\n        // TODO: #TWITTER-V2-004 - Reimplement spaces logic using Twitter API v2\n        // // If Spaces are enabled, start the periodic check\n        // if (manager.space) {\n        //     manager.space.startPeriodicSpaceCheck();\n        // }\n\n        return manager;\n    },\n};","import {\n    type Content,\n    type IAgentRuntime,\n    type IImageDescriptionService,\n    type Memory,\n    type State,\n    type UUID,\n    getEmbeddingZeroVector,\n    elizaLogger,\n    stringToUuid,\n    ActionTimelineType,\n} from \"@elizaos/core\";\nimport {\n    TwitterApi,\n    TweetV2,\n    UserV2,\n    TwitterV2IncludesHelper\n} from \"twitter-api-v2\";\nimport { EventEmitter } from \"events\";\nimport type { TwitterConfig } from \"./environment.ts\";\nimport type { ElizaTweet, TwitterProfile } from \"./types.ts\";\nimport { createElizaTweet } from \"./utils.ts\";\n\nexport function extractAnswer(text: string): string {\n    const startIndex = text.indexOf(\"Answer: \") + 8;\n    const endIndex = text.indexOf(\"<|endoftext|>\", 11);\n    return text.slice(startIndex, endIndex);\n}\n\ninterface QueryTweetsResponse {\n    tweets: TweetV2[];\n    next?: string;\n    previous?: string;\n}\n\n// create a default profile\nconst defaultProfile: TwitterProfile = {\n    id: \"\",\n    username: \"\",\n    name: \"\",\n    bio: \"\",\n    nicknames: [],\n};\n\nclass RequestQueue {\n    private queue: (() => Promise<any>)[] = [];\n    private processing = false;\n\n    async add<T>(request: () => Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.queue.push(async () => {\n                try {\n                    const result = await request();\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            this.processQueue();\n        });\n    }\n\n    private async processQueue(): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const request = this.queue.shift()!;\n            try {\n                await request();\n            } catch (error) {\n                console.error(\"Error processing request:\", error);\n                this.queue.unshift(request);\n                await this.exponentialBackoff(this.queue.length);\n            }\n            await this.randomDelay();\n        }\n\n        this.processing = false;\n    }\n\n    private async exponentialBackoff(retryCount: number): Promise<void> {\n        const delay = Math.pow(2, retryCount) * 1000;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n\n    private async randomDelay(): Promise<void> {\n        const delay = Math.floor(Math.random() * 2000) + 1500;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n}\n\nexport class ClientBase extends EventEmitter {\n    static _twitterClients: { [accountIdentifier: string]: TwitterApi } = {};\n    twitterClient: TwitterApi;\n    runtime: IAgentRuntime;\n    twitterConfig: TwitterConfig;\n    directions: string;\n    lastCheckedTweetId: bigint | null = null;\n    imageDescriptionService: IImageDescriptionService;\n    temperature = 0.5;\n\n    requestQueue: RequestQueue = new RequestQueue();\n\n    profile: TwitterProfile | null;\n\n    async cacheTweet(tweet: TweetV2): Promise<void> {\n        if (!tweet) {\n            console.warn(\"Tweet is undefined, skipping cache\");\n            return;\n        }\n\n        this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);\n    }\n\n    async getCachedTweet(tweetId: string): Promise<TweetV2 | undefined> {\n        const cached = await this.runtime.cacheManager.get<TweetV2>(\n            `twitter/tweets/${tweetId}`\n        );\n\n        return cached;\n    }\n\n    async getTweet(tweetId: string): Promise<TweetV2> {\n        const cachedTweet = await this.getCachedTweet(tweetId);\n\n        if (cachedTweet) {\n            return cachedTweet;\n        }\n\n        // TODO replace with v2 api call\n        // const tweet = await this.requestQueue.add(() =>\n            // this.twitterClient.getTweet(tweetId)\n        // );\n\n        // await this.cacheTweet(tweet);\n        // return tweet;\n        return\n    }\n\n    callback: (self: ClientBase) => any = null;\n\n    onReady() {\n        throw new Error(\n            \"Not implemented in base class, please call from subclass\"\n        );\n    }\n\n    /**\n     * Parse the raw tweet data into a standardized Tweet object.\n     */\n    private parseTweet(raw: any, depth = 0, maxDepth = 3): TweetV2 {\n        // If we've reached maxDepth, don't parse nested quotes/retweets further\n        const canRecurse = depth < maxDepth;\n\n        const quotedStatus = raw.quoted_status_result?.result && canRecurse\n            ? this.parseTweet(raw.quoted_status_result.result, depth + 1, maxDepth)\n            : undefined;\n\n        const retweetedStatus = raw.retweeted_status_result?.result && canRecurse\n            ? this.parseTweet(raw.retweeted_status_result.result, depth + 1, maxDepth)\n            : undefined;\n\n        const t: TweetV2 = {\n            id: \"\",\n            text: \"\",\n            edit_history_tweet_ids: []\n        };\n\n\n        return t;\n    }\n\n    constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\n        super();\n        this.runtime = runtime;\n        this.twitterConfig = twitterConfig;\n        this.profile = defaultProfile;\n\n        this.twitterClient = new TwitterApi({\n            appKey: this.twitterConfig.TWITTER_APP_KEY,\n            appSecret: this.twitterConfig.TWITTER_APP_SECRET,\n            accessToken: this.twitterConfig.TWITTER_ACCESS_TOKEN,\n            accessSecret: this.twitterConfig.TWITTER_ACCESS_SECRET\n        });\n\n        elizaLogger.info(\"Twitter client initialized with access token and access secret.\");\n\n        this.runtime.character.style.all.join(\"\\n- \") +\n        \"- \" +\n        this.runtime.character.style.post.join();\n    }\n\n    async init() {\n        // initialize Twitter profile of authenticated user\n        this.profile = await this.fetchProfile();\n\n        if (this.profile) {\n            elizaLogger.log(\"Twitter user ID:\", this.profile.id);\n            elizaLogger.log(\n                \"Twitter loaded:\",\n                JSON.stringify(this.profile, null, 10)\n            );\n            // Store profile info for use in responses\n            this.runtime.character.twitterProfile = {\n                id: this.profile.id,\n                username: this.profile.username,\n                name: this.profile.name,\n                bio: this.profile.bio,\n                nicknames: this.profile.nicknames,\n            };\n        } else {\n            throw new Error(\"Failed to load profile\");\n        }\n    }\n\n    async fetchOwnPosts(count: number): Promise<TweetV2[]> {\n        elizaLogger.debug(\"fetching own posts\");\n        // TODO replace with v2 api call\n        // const homeTimeline = await this.twitterClient.getUserTweets(\n        //     this.profile.id,\n        //     count\n        // );\n        // // Use parseTweet on each tweet\n        // return homeTimeline.tweets.map((t) => this.parseTweet(t));\n        return [];\n    }\n\n    /**\n     * Fetch timeline for twitter account, optionally only from followed accounts\n     */\n    async fetchHomeTimeline(\n        count: number,\n        following?: boolean\n    ): Promise<TweetV2[]> {\n        elizaLogger.debug(\"fetching home timeline\");\n        // TODO replace with v2 api call\n        // const homeTimeline = following\n        //     ? await this.twitterClient.fetchFollowingTimeline(count, [])\n        //     : await this.twitterClient.fetchHomeTimeline(count, []);\n\n        // elizaLogger.debug(homeTimeline, { depth: Number.POSITIVE_INFINITY });\n        // const processedTimeline = homeTimeline\n        //     .filter((t) => t.__typename !== \"TweetWithVisibilityResults\") // what's this about?\n        //     .map((tweet) => this.parseTweet(tweet));\n\n        // //elizaLogger.debug(\"process homeTimeline\", processedTimeline);\n        // return processedTimeline;\n        return [];\n    }\n\n    async fetchTimelineForActions(count: number): Promise<TweetV2[]> {\n        elizaLogger.debug(\"fetching timeline for actions\");\n\n        // TODO replace with v2 api call\n        // const agentUsername = this.twitterConfig.TWITTER_USERNAME;\n\n        // const homeTimeline =\n        //     this.twitterConfig.ACTION_TIMELINE_TYPE ===\n        //     ActionTimelineType.Following\n        //         ? await this.twitterClient.fetchFollowingTimeline(count, [])\n        //         : await this.twitterClient.fetchHomeTimeline(count, []);\n\n        // // Parse, filter out self-tweets, limit to count\n        // return homeTimeline\n        //     .map((tweet) => this.parseTweet(tweet))\n        //     .filter((tweet) => tweet.username !== agentUsername) // do not perform action on self-tweets\n        //     .slice(0, count);\n        // TODO: Once the 'count' parameter is fixed in the 'fetchTimeline' method of the 'agent-twitter-client',\n        // this workaround can be removed.\n        // Related issue: https://github.com/elizaos/agent-twitter-client/issues/43\n        return [];\n    }\n\n    async fetchSearchTweets(\n        query: string,\n        maxTweets: number,\n        // searchMode: SearchMode,\n        cursor?: string\n    ): Promise<QueryTweetsResponse> {\n        try {\n            // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\n            // if we dont get a response in 5 seconds, something is wrong\n            const timeoutPromise = new Promise((resolve) =>\n                setTimeout(() => resolve({ tweets: [] }), 15000)\n            );\n\n            try {\n                const result = await this.requestQueue.add(\n                    // TODO replace with v2 api call \n                    // async () =>\n                    //     await Promise.race([\n                    //         this.twitterClient.fetchSearchTweets(\n                    //             query,\n                    //             maxTweets,\n                    //             searchMode,\n                    //             cursor\n                    //         ),\n                    //         timeoutPromise,\n                    //     ])\n                );\n                return (result ?? { tweets: [] }) as QueryTweetsResponse;\n            } catch (error) {\n                elizaLogger.error(\"Error fetching search tweets:\", error);\n                return { tweets: [] };\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error fetching search tweets:\", error);\n            return { tweets: [] };\n        }\n    }\n\n    async getMentions(\n        userId: string,\n        count: number,\n        options?: {\n            \"tweet.fields\"?: string[];\n            \"expansions\"?: string[];\n        }\n    ): Promise<ElizaTweet[]> {\n        elizaLogger.debug(\"fetching mentions\");\n\n        // default options\n        const defaultFields = [\"created_at\", \"author_id\", \"conversation_id\", \"entities\", \"referenced_tweets\", \"text\"];\n        const defaultExpansions = [\"author_id\"];\n\n        // select options or defaults\n        const tweetFields = options?.[\"tweet.fields\"] || defaultFields;\n        const expansions = options?.[\"expansions\"] || defaultExpansions;\n\n        // fetch mentions\n        const mentions = await this.requestQueue.add(async () => {\n            return await this.twitterClient.v2.userMentionTimeline(userId, {\n                max_results: count,\n                \"tweet.fields\": tweetFields.join(\",\"),\n                \"expansions\": expansions.join(\",\")\n            });\n        });\n        \n        return mentions.tweets.map((tweet) => createElizaTweet(tweet, mentions.includes));\n    }\n\n    private async populateTimeline() {\n        elizaLogger.debug(\"populating timeline...\");\n\n        const cachedTimeline = await this.getCachedTimeline();\n\n        // Check if the cache file exists\n        if (cachedTimeline) {\n            // Read the cached search results from the file\n\n            // Get the existing memories from the database\n            const existingMemories =\n                await this.runtime.messageManager.getMemoriesByRoomIds({\n                    roomIds: cachedTimeline.map((tweet) =>\n                        stringToUuid(\n                            tweet.conversationId + \"-\" + this.runtime.agentId\n                        )\n                    ),\n                });\n\n            //TODO: load tweets not in cache?\n\n            // Create a Set to store the IDs of existing memories\n            const existingMemoryIds = new Set(\n                existingMemories.map((memory) => memory.id.toString())\n            );\n\n            // Check if any of the cached tweets exist in the existing memories\n            const someCachedTweetsExist = cachedTimeline.some((tweet) =>\n                existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n            );\n\n            if (someCachedTweetsExist) {\n                // Filter out the cached tweets that already exist in the database\n                const tweetsToSave = cachedTimeline.filter(\n                    (tweet) =>\n                        !existingMemoryIds.has(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        )\n                );\n\n                console.log({\n                    processingTweets: tweetsToSave\n                        .map((tweet) => tweet.id)\n                        .join(\",\"),\n                });\n\n                // Save the missing tweets as memories\n                for (const tweet of tweetsToSave) {\n                    elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userId =\n                        tweet.userId === this.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId);\n\n                    if (tweet.userId === this.profile.id) {\n                        await this.runtime.ensureConnection(\n                            this.runtime.agentId,\n                            roomId,\n                            this.profile.username,\n                            this.profile.name,\n                            \"twitter\"\n                        );\n                    } else {\n                        await this.runtime.ensureConnection(\n                            userId,\n                            roomId,\n                            tweet.username,\n                            tweet.name,\n                            \"twitter\"\n                        );\n                    }\n\n                    const content = {\n                        text: tweet.text,\n                        url: tweet.permanentUrl,\n                        source: \"twitter\",\n                        inReplyTo: tweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  tweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    } as Content;\n\n                    elizaLogger.log(\"Creating memory for tweet\", tweet.id);\n\n                    // check if it already exists\n                    const memory =\n                        await this.runtime.messageManager.getMemoryById(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        );\n\n                    if (memory) {\n                        elizaLogger.log(\n                            \"Memory already exists, skipping timeline population\"\n                        );\n                        break;\n                    }\n\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId,\n                        content: content,\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n\n                    await this.cacheTweet(tweet);\n                }\n\n                elizaLogger.log(\n                    `Populated ${tweetsToSave.length} missing tweets from the cache.`\n                );\n                return;\n            }\n        }\n\n        const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);\n        const username = this.profile?.username;\n\n        // Get the most recent 20 mentions and interactions\n        const mentionsAndInteractions = await this.fetchSearchTweets(\n            `@${username}`,\n            20,\n            // SearchMode.Latest\n        );\n\n        // Combine the timeline tweets and mentions/interactions\n        const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\n\n        // Create a Set to store unique tweet IDs\n        const tweetIdsToCheck = new Set<string>();\n        const roomIds = new Set<UUID>();\n\n        // Add tweet IDs to the Set\n        for (const tweet of allTweets) {\n            tweetIdsToCheck.add(tweet.id);\n            roomIds.add(\n                stringToUuid(tweet.conversationId + \"-\" + this.runtime.agentId)\n            );\n        }\n\n        // Check the existing memories in the database\n        const existingMemories =\n            await this.runtime.messageManager.getMemoriesByRoomIds({\n                roomIds: Array.from(roomIds),\n            });\n\n        // Create a Set to store the existing memory IDs\n        const existingMemoryIds = new Set<UUID>(\n            existingMemories.map((memory) => memory.id)\n        );\n\n        // Filter out the tweets that already exist in the database\n        const tweetsToSave = allTweets.filter(\n            (tweet) =>\n                !existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n        );\n\n        elizaLogger.debug({\n            processingTweets: tweetsToSave.map((tweet) => tweet.id).join(\",\"),\n        });\n\n        await this.runtime.ensureUserExists(\n            this.runtime.agentId,\n            this.profile.username,\n            this.runtime.character.name,\n            \"twitter\"\n        );\n\n        // Save the new tweets as memories\n        for (const tweet of tweetsToSave) {\n            elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n            const roomId = stringToUuid(\n                tweet.conversationId + \"-\" + this.runtime.agentId\n            );\n            const userId =\n                tweet.userId === this.profile.id\n                    ? this.runtime.agentId\n                    : stringToUuid(tweet.userId);\n\n            if (tweet.userId === this.profile.id) {\n                await this.runtime.ensureConnection(\n                    this.runtime.agentId,\n                    roomId,\n                    this.profile.username,\n                    this.profile.name,\n                    \"twitter\"\n                );\n            } else {\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    tweet.username,\n                    tweet.name,\n                    \"twitter\"\n                );\n            }\n\n            const content = {\n                text: tweet.text,\n                url: tweet.permanentUrl,\n                source: \"twitter\",\n                inReplyTo: tweet.inReplyToStatusId\n                    ? stringToUuid(tweet.inReplyToStatusId)\n                    : undefined,\n            } as Content;\n\n            await this.runtime.messageManager.createMemory({\n                id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                userId,\n                content: content,\n                agentId: this.runtime.agentId,\n                roomId,\n                embedding: getEmbeddingZeroVector(),\n                createdAt: tweet.timestamp * 1000,\n            });\n\n            await this.cacheTweet(tweet);\n        }\n\n        // Cache\n        await this.cacheTimeline(timeline);\n        await this.cacheMentions(mentionsAndInteractions.tweets);\n    }\n\n    async setCookiesFromArray(cookiesArray: any[]) {\n        const cookieStrings = cookiesArray.map(\n            (cookie) =>\n                `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${\n                    cookie.secure ? \"Secure\" : \"\"\n                }; ${cookie.httpOnly ? \"HttpOnly\" : \"\"}; SameSite=${\n                    cookie.sameSite || \"Lax\"\n                }`\n        );\n        await this.twitterClient.setCookies(cookieStrings);\n    }\n\n    async saveRequestMessage(message: Memory, state: State) {\n        if (message.content.text) {\n            const recentMessage = await this.runtime.messageManager.getMemories(\n                {\n                    roomId: message.roomId,\n                    count: 1,\n                    unique: false,\n                }\n            );\n\n            if (\n                recentMessage.length > 0 &&\n                recentMessage[0].content === message.content\n            ) {\n                elizaLogger.debug(\"Message already saved\", recentMessage[0].id);\n            } else {\n                await this.runtime.messageManager.createMemory({\n                    ...message,\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            await this.runtime.evaluate(message, {\n                ...state,\n                twitterClient: this.twitterClient,\n            });\n        }\n    }\n\n    async loadLatestCheckedTweetId(): Promise<void> {\n        const latestCheckedTweetId =\n            await this.runtime.cacheManager.get<string>(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`\n            );\n\n        if (latestCheckedTweetId) {\n            this.lastCheckedTweetId = BigInt(latestCheckedTweetId);\n        }\n    }\n\n    async cacheLatestCheckedTweetId() {\n        if (this.lastCheckedTweetId) {\n            await this.runtime.cacheManager.set(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`,\n                this.lastCheckedTweetId.toString()\n            );\n        }\n    }\n\n    async getCachedTimeline(): Promise<ElizaTweet[] | undefined> {\n        return await this.runtime.cacheManager.get<ElizaTweet[]>(\n            `twitter/${this.profile.username}/timeline`\n        );\n    }\n\n    async cacheTimeline(timeline: ElizaTweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/timeline`,\n            timeline,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async cacheMentions(mentions: ElizaTweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/mentions`,\n            mentions,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async getCachedCookies(username: string) {\n        return await this.runtime.cacheManager.get<any[]>(\n            `twitter/${username}/cookies`\n        );\n    }\n\n    async cacheCookies(username: string, cookies: any[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${username}/cookies`,\n            cookies\n        );\n    }\n\n    async getAuthenticatedUserData(): Promise<UserV2> {\n        try {\n            const user = await this.requestQueue.add(async () => {\n                return await this.twitterClient.v2.me({\n                    'user.fields': 'description',\n                });\n            });\n            \n            elizaLogger.debug(\"Authenticated User's data:\", user);\n            \n            return user.data;\n        } catch (error) {\n            elizaLogger.error('Error fetching authenticated user info:', error);\n            throw error;\n        }\n    }\n\n    async fetchProfile(): Promise<TwitterProfile> {\n        elizaLogger.info(\"Fetching profile of authenticated user.\");\n        const userData = await this.getAuthenticatedUserData();\n\n        return {\n            id: userData.id,\n            username: userData.username,\n            name: userData.name,\n            bio: userData.description,\n            nicknames: [],\n        };\n    }\n}\n","import type { Tweet } from \"agent-twitter-client\";\nimport { getEmbeddingZeroVector } from \"@elizaos/core\";\nimport type { Content, Memory, UUID } from \"@elizaos/core\";\nimport { stringToUuid } from \"@elizaos/core\";\nimport type { ClientBase } from \"./base\";\nimport { elizaLogger } from \"@elizaos/core\";\nimport type { Media } from \"@elizaos/core\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { ElizaTweet, MediaData } from \"./types\";\nimport { SendTweetV2Params, TweetV2 } from \"twitter-api-v2\";\nimport { TwitterV2IncludesHelper } from \"twitter-api-v2\";\n\nexport const wait = (minTime = 1000, maxTime = 3000) => {\n    const waitTime =\n        Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\n};\n\nexport const isValidTweet = (tweet: Tweet): boolean => {\n    // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\n    const hashtagCount = (tweet.text?.match(/#/g) || []).length;\n    const atCount = (tweet.text?.match(/@/g) || []).length;\n    const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\n    const totalCount = hashtagCount + atCount + dollarSignCount;\n\n    return (\n        hashtagCount <= 1 &&\n        atCount <= 2 &&\n        dollarSignCount <= 1 &&\n        totalCount <= 3\n    );\n};\n\nexport async function buildConversationThread(\n    tweet: ElizaTweet,\n    client: ClientBase,\n    maxReplies = 10\n): Promise<ElizaTweet[]> {\n    const thread: ElizaTweet[] = [];\n    const visited: Set<string> = new Set();\n\n    async function processThread(currentTweet: ElizaTweet, depth = 0) {\n        elizaLogger.debug(\"Processing tweet:\", {\n            id: currentTweet.id,\n            inReplyToStatusId: currentTweet.inReplyToStatusId,\n            depth: depth,\n        });\n\n        if (!currentTweet) {\n            elizaLogger.debug(\"No current tweet found for thread building\");\n            return;\n        }\n\n        // Stop if we've reached our reply limit\n        if (depth >= maxReplies) {\n            elizaLogger.debug(\"Reached maximum reply depth\", depth);\n            return;\n        }\n\n        // Handle memory storage\n        const memory = await client.runtime.messageManager.getMemoryById(\n            stringToUuid(currentTweet.id + \"-\" + client.runtime.agentId)\n        );\n        if (!memory) {\n            const roomId = stringToUuid(\n                currentTweet.conversationId + \"-\" + client.runtime.agentId\n            );\n            const userId = stringToUuid(currentTweet.authorId);\n\n            await client.runtime.ensureConnection(\n                userId,\n                roomId,\n                currentTweet.authorUsername,\n                currentTweet.authorName,\n                \"twitter\"\n            );\n\n            await client.runtime.messageManager.createMemory({\n                id: stringToUuid(\n                    currentTweet.id + \"-\" + client.runtime.agentId\n                ),\n                agentId: client.runtime.agentId,\n                content: {\n                    text: currentTweet.text,\n                    source: \"twitter\",\n                    url: currentTweet.permanentUrl,\n                    imageUrls: currentTweet.photos.map((p) => p.url) || [],\n                    inReplyTo: currentTweet.inReplyToStatusId\n                        ? stringToUuid(\n                              currentTweet.inReplyToStatusId +\n                                  \"-\" +\n                                  client.runtime.agentId\n                          )\n                        : undefined,\n                },\n                createdAt: currentTweet.timestamp * 1000,\n                roomId,\n                userId:\n                    currentTweet.authorId === client.profile.id\n                        ? client.runtime.agentId\n                        : stringToUuid(currentTweet.authorId),\n                embedding: getEmbeddingZeroVector(),\n            });\n        }\n\n        if (visited.has(currentTweet.id)) {\n            elizaLogger.debug(\"Already visited tweet:\", currentTweet.id);\n            return;\n        }\n\n        visited.add(currentTweet.id);\n        thread.unshift(currentTweet);\n\n        elizaLogger.debug(\"Current thread state:\", {\n            length: thread.length,\n            currentDepth: depth,\n            tweetId: currentTweet.id,\n        });\n\n        // If there's a parent tweet, fetch and process it\n        if (currentTweet.inReplyToStatusId) {\n            elizaLogger.debug(\n                \"Fetching parent tweet:\",\n                currentTweet.inReplyToStatusId\n            );\n            try {\n                const parentTweetResult = await client.requestQueue.add(async () => {\n                    return await client.twitterClient.v2.singleTweet(currentTweet.inReplyToStatusId, {\n                        \"tweet.fields\": \"created_at,author_id,conversation_id,entities,referenced_tweets,text\",\n                        \"expansions\": \"author_id,referenced_tweets.id\"\n                    })\n                });\n                const parentTweet = createElizaTweet(parentTweetResult.data, new TwitterV2IncludesHelper(parentTweetResult));\n\n                if (parentTweet) {\n                    elizaLogger.debug(\"Found parent tweet:\", {\n                        id: parentTweet.id,\n                        text: parentTweet.text?.slice(0, 50),\n                    });\n                    await processThread(parentTweet, depth + 1);\n                } else {\n                    elizaLogger.debug(\n                        \"No parent tweet found for:\",\n                        currentTweet.inReplyToStatusId\n                    );\n                }\n            } catch (error) {\n                elizaLogger.error(\"Error fetching parent tweet:\", {\n                    tweetId: currentTweet.inReplyToStatusId,\n                    error,\n                });\n            }\n        } else {\n            elizaLogger.debug(\n                \"Reached end of reply chain at:\",\n                currentTweet.id\n            );\n        }\n    }\n\n    await processThread(tweet, 0);\n\n    elizaLogger.debug(\"Final thread built:\", {\n        totalTweets: thread.length,\n        tweetIds: thread.map((t) => ({\n            id: t.id,\n            text: t.text?.slice(0, 50),\n        })),\n    });\n\n    return thread;\n}\n\nexport async function fetchMediaData(\n    attachments: Media[]\n): Promise<MediaData[]> {\n    return Promise.all(\n        attachments.map(async (attachment: Media) => {\n            if (/^(http|https):\\/\\//.test(attachment.url)) {\n                // Handle HTTP URLs\n                const response = await fetch(attachment.url);\n                if (!response.ok) {\n                    throw new Error(`Failed to fetch file: ${attachment.url}`);\n                }\n                const mediaBuffer = Buffer.from(await response.arrayBuffer());\n                const mediaType = attachment.contentType;\n                return { data: mediaBuffer, mediaType };\n            } else if (fs.existsSync(attachment.url)) {\n                // Handle local file paths\n                const mediaBuffer = await fs.promises.readFile(\n                    path.resolve(attachment.url)\n                );\n                const mediaType = attachment.contentType;\n                return { data: mediaBuffer, mediaType };\n            } else {\n                throw new Error(\n                    `File not found: ${attachment.url}. Make sure the path is correct.`\n                );\n            }\n        })\n    );\n}\n\nexport async function sendTweet(\n    client: ClientBase,\n    content: Content,\n    roomId: UUID,\n    twitterUsername: string,\n    inReplyTo: string\n): Promise<Memory[]> {\n    const maxTweetLength = client.twitterConfig.MAX_TWEET_LENGTH;\n    const isLongTweet = maxTweetLength > 280;\n\n    const tweetChunks = splitTweetContent(content.text, maxTweetLength);\n    const sentTweets: Tweet[] = [];\n    let previousTweetId = inReplyTo;\n\n    for (const chunk of tweetChunks) {\n        let mediaData = null;\n\n        if (content.attachments && content.attachments.length > 0) {\n            mediaData = await fetchMediaData(content.attachments);\n        }\n\n        const cleanChunk = deduplicateMentions(chunk.trim());\n\n        const tweetData: SendTweetV2Params = {\n            text: cleanChunk,\n            reply: {\n                in_reply_to_tweet_id: previousTweetId\n            }\n        };\n\n        if (mediaData) {\n            // Upload media and get media IDs\n            const mediaIds = await Promise.all(\n                mediaData.map(async (media) => {\n                    const mediaId = await client.twitterClient.v2.uploadMedia(\n                        media.data,\n                        { media_type: media.mediaType }\n                    );\n                    return mediaId;\n                })\n            );\n            tweetData.media = { media_ids: mediaIds as [string, string, string, string] };\n        }\n\n        const result = await client.requestQueue.add(async () =>\n            client.twitterClient.v2.tweet(tweetData)\n        );\n\n        // fetch the tweet that was just posted\n        const tweetResult = await client.requestQueue.add(async () =>\n            client.twitterClient.v2.singleTweet(result.data.id, {\n                \"tweet.fields\": \"created_at,author_id,conversation_id,entities,referenced_tweets,text\",\n                \"expansions\": \"author_id\"\n            })\n        );\n\n        const finalTweet = createElizaTweet(tweetResult.data, new TwitterV2IncludesHelper(tweetResult));\n\n        sentTweets.push(finalTweet);\n        previousTweetId = finalTweet.id;\n    }\n\n    const memories: Memory[] = sentTweets.map((tweet) => ({\n        id: stringToUuid(`${tweet.id}-${client.runtime.agentId}`),\n        agentId: client.runtime.agentId,\n        userId: client.runtime.agentId,\n        content: {\n            tweetId: tweet.id,\n            text: tweet.text,\n            source: \"twitter\",\n            url: tweet.permanentUrl,\n            imageUrls: tweet.photos.map((p) => p.url) || [],\n            inReplyTo: tweet.inReplyToStatusId\n                ? stringToUuid(\n                      tweet.inReplyToStatusId + \"-\" + client.runtime.agentId\n                  )\n                : undefined,\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: tweet.timestamp * 1000, \n    }));\n\n    return memories;\n}\n\nfunction splitTweetContent(content: string, maxLength: number): string[] {\n    const paragraphs = content.split(\"\\n\\n\").map((p) => p.trim());\n    const tweets: string[] = [];\n    let currentTweet = \"\";\n\n    for (const paragraph of paragraphs) {\n        if (!paragraph) continue;\n\n        if ((currentTweet + \"\\n\\n\" + paragraph).trim().length <= maxLength) {\n            if (currentTweet) {\n                currentTweet += \"\\n\\n\" + paragraph;\n            } else {\n                currentTweet = paragraph;\n            }\n        } else {\n            if (currentTweet) {\n                tweets.push(currentTweet.trim());\n            }\n            if (paragraph.length <= maxLength) {\n                currentTweet = paragraph;\n            } else {\n                // Split long paragraph into smaller chunks\n                const chunks = splitParagraph(paragraph, maxLength);\n                tweets.push(...chunks.slice(0, -1));\n                currentTweet = chunks[chunks.length - 1];\n            }\n        }\n    }\n\n    if (currentTweet) {\n        tweets.push(currentTweet.trim());\n    }\n\n    return tweets;\n}\n\nfunction extractUrls(paragraph: string): {\n    textWithPlaceholders: string;\n    placeholderMap: Map<string, string>;\n} {\n    // replace https urls with placeholder\n    const urlRegex = /https?:\\/\\/[^\\s]+/g;\n    const placeholderMap = new Map<string, string>();\n\n    let urlIndex = 0;\n    const textWithPlaceholders = paragraph.replace(urlRegex, (match) => {\n        // twitter url would be considered as 23 characters\n        // <<URL_CONSIDERER_23_1>> is also 23 characters\n        const placeholder = `<<URL_CONSIDERER_23_${urlIndex}>>`; // Placeholder without . ? ! etc\n        placeholderMap.set(placeholder, match);\n        urlIndex++;\n        return placeholder;\n    });\n\n    return { textWithPlaceholders, placeholderMap };\n}\n\nfunction splitSentencesAndWords(text: string, maxLength: number): string[] {\n    // Split by periods, question marks and exclamation marks\n    // Note that URLs in text have been replaced with `<<URL_xxx>>` and won't be split by dots\n    const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];\n    const chunks: string[] = [];\n    let currentChunk = \"\";\n\n    for (const sentence of sentences) {\n        if ((currentChunk + \" \" + sentence).trim().length <= maxLength) {\n            if (currentChunk) {\n                currentChunk += \" \" + sentence;\n            } else {\n                currentChunk = sentence;\n            }\n        } else {\n            // Can't fit more, push currentChunk to results\n            if (currentChunk) {\n                chunks.push(currentChunk.trim());\n            }\n\n            // If current sentence itself is less than or equal to maxLength\n            if (sentence.length <= maxLength) {\n                currentChunk = sentence;\n            } else {\n                // Need to split sentence by spaces\n                const words = sentence.split(\" \");\n                currentChunk = \"\";\n                for (const word of words) {\n                    if (\n                        (currentChunk + \" \" + word).trim().length <= maxLength\n                    ) {\n                        if (currentChunk) {\n                            currentChunk += \" \" + word;\n                        } else {\n                            currentChunk = word;\n                        }\n                    } else {\n                        if (currentChunk) {\n                            chunks.push(currentChunk.trim());\n                        }\n                        currentChunk = word;\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle remaining content\n    if (currentChunk) {\n        chunks.push(currentChunk.trim());\n    }\n\n    return chunks;\n}\n\nfunction deduplicateMentions(paragraph: string) {\n    // Regex to match mentions at the beginning of the string\n  const mentionRegex = /^@(\\w+)(?:\\s+@(\\w+))*(\\s+|$)/;\n\n  // Find all matches\n  const matches = paragraph.match(mentionRegex);\n\n  if (!matches) {\n    return paragraph; // If no matches, return the original string\n  }\n\n  // Extract mentions from the match groups\n  let mentions = matches.slice(0, 1)[0].trim().split(' ')\n\n  // Deduplicate mentions\n  mentions = [...new Set(mentions)];\n\n  // Reconstruct the string with deduplicated mentions\n  const uniqueMentionsString = mentions.join(' ');\n\n  // Find where the mentions end in the original string\n  const endOfMentions = paragraph.indexOf(matches[0]) + matches[0].length;\n\n  // Construct the result by combining unique mentions with the rest of the string\n  return uniqueMentionsString + ' ' + paragraph.slice(endOfMentions);\n}\n\nfunction restoreUrls(\n    chunks: string[],\n    placeholderMap: Map<string, string>\n): string[] {\n    return chunks.map((chunk) => {\n        // Replace all <<URL_CONSIDERER_23_>> in chunk back to original URLs using regex\n        return chunk.replace(/<<URL_CONSIDERER_23_(\\d+)>>/g, (match) => {\n            const original = placeholderMap.get(match);\n            return original || match; // Return placeholder if not found (theoretically won't happen)\n        });\n    });\n}\n\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\n    // 1) Extract URLs and replace with placeholders\n    const { textWithPlaceholders, placeholderMap } = extractUrls(paragraph);\n\n    // 2) Use first section's logic to split by sentences first, then do secondary split\n    const splittedChunks = splitSentencesAndWords(\n        textWithPlaceholders,\n        maxLength\n    );\n\n    // 3) Replace placeholders back to original URLs\n    const restoredChunks = restoreUrls(splittedChunks, placeholderMap);\n\n    return restoredChunks;\n}\n\nexport function createElizaTweet(fetchedTweetResult: TweetV2, includes: TwitterV2IncludesHelper): ElizaTweet {\n    if (!fetchedTweetResult) {\n        return null;\n    }\n\n    // get the author\n    const author = includes.author(fetchedTweetResult);\n\n    // get the replied to tweet id\n    let repliedToId = null;\n    if (fetchedTweetResult.referenced_tweets && fetchedTweetResult.referenced_tweets.length > 0) {\n        for (const referencedTweet of fetchedTweetResult.referenced_tweets) {\n            if (referencedTweet.type === \"replied_to\") {\n                repliedToId = referencedTweet.id;\n            }\n        }\n    }\n\n    // create the tweet\n    const tweet: ElizaTweet = {\n        id: fetchedTweetResult.id,\n        text: fetchedTweetResult.text,\n        conversationId: fetchedTweetResult.conversation_id,\n        timestamp: fetchedTweetResult.created_at ? new Date(fetchedTweetResult.created_at).getTime() : null,\n        authorId: author.id,\n        authorName: author.name,\n        authorUsername: author.username,\n        photos: [],\n        thread: [],\n        videos: [],\n        mentions: fetchedTweetResult.entities?.mentions?.map((mention) => mention.username) || [],\n        permanentUrl: `https://x.com/${author.username}/status/${fetchedTweetResult.id}`,\n        inReplyToStatusId: repliedToId,\n        isReply: !!repliedToId,\n        isRetweet: false,\n    }\n    \n    return tweet;\n}","import {\n    parseBooleanFromText,\n    type IAgentRuntime,\n    ActionTimelineType,\n} from \"@elizaos/core\";\nimport { z, ZodError } from \"zod\";\n\nexport const DEFAULT_MAX_TWEET_LENGTH = 280;\n\nconst twitterUsernameSchema = z\n    .string()\n    .min(1, \"An X/Twitter Username must be at least 1 character long\")\n    .max(15, \"An X/Twitter Username cannot exceed 15 characters\")\n    .refine((username) => {\n        // Allow wildcard '*' as a special case\n        if (username === \"*\") return true;\n\n        // Twitter usernames can:\n        // - Start with digits now\n        // - Contain letters, numbers, underscores\n        // - Must not be empty\n        return /^[A-Za-z0-9_]+$/.test(username);\n    }, \"An X Username can only contain letters, numbers, and underscores\");\n\n/**\n * This schema defines all required/optional environment settings,\n * including new fields like TWITTER_SPACES_ENABLE.\n */\nexport const twitterEnvSchema = z.object({\n    TWITTER_DRY_RUN: z.boolean(),\n    TWITTER_APP_KEY: z.string().min(1, \"X/Twitter App Key is required\"),\n    TWITTER_APP_SECRET: z.string().min(1, \"X/Twitter App Secret is required\"),\n    TWITTER_ACCESS_TOKEN: z.string().min(1, \"X/Twitter Access Token is required\"),\n    TWITTER_ACCESS_SECRET: z.string().min(1, \"X/Twitter Access Secret is required\"),\n    MAX_TWEET_LENGTH: z.number().int().default(DEFAULT_MAX_TWEET_LENGTH),\n    TWITTER_SEARCH_ENABLE: z.boolean().default(false),\n    TWITTER_RETRY_LIMIT: z.number().int(),\n    TWITTER_POLL_INTERVAL: z.number().int(),\n    TWITTER_TARGET_USERS: z.array(twitterUsernameSchema).default([]),\n    ENABLE_TWITTER_POST_GENERATION: z.boolean().default(true),\n    POST_INTERVAL_MIN: z.number().int(),\n    POST_INTERVAL_MAX: z.number().int(),\n    ENABLE_ACTION_PROCESSING: z.boolean().default(false),\n    ACTION_INTERVAL: z.number().int(),\n    POST_IMMEDIATELY: z.boolean().default(false),\n    TWITTER_SPACES_ENABLE: z.boolean().default(false),\n    MAX_ACTIONS_PROCESSING: z.number().int(),\n    ACTION_TIMELINE_TYPE: z\n        .nativeEnum(ActionTimelineType)\n        .default(ActionTimelineType.ForYou),\n});\n\nexport type TwitterConfig = z.infer<typeof twitterEnvSchema>;\n\n/**\n * Helper to parse a comma-separated list of Twitter usernames\n * (already present in your code).\n */\nfunction parseTargetUsers(targetUsersStr?: string | null): string[] {\n    if (!targetUsersStr?.trim()) {\n        return [];\n    }\n    return targetUsersStr\n        .split(\",\")\n        .map((user) => user.trim())\n        .filter(Boolean);\n}\n\nfunction safeParseInt(\n    value: string | undefined | null,\n    defaultValue: number\n): number {\n    if (!value) return defaultValue;\n    const parsed = Number.parseInt(value, 10);\n    return isNaN(parsed) ? defaultValue : Math.max(1, parsed);\n}\n\n/**\n * Validates or constructs a TwitterConfig object using zod,\n * taking values from the IAgentRuntime or process.env as needed.\n */\n// This also is organized to serve as a point of documentation for the client\n// most of the inputs from the framework (env/character)\n\n// we also do a lot of typing/parsing here\n// so we can do it once and only once per character\nexport async function validateTwitterConfig(\n    runtime: IAgentRuntime\n): Promise<TwitterConfig> {\n    try {\n        const twitterConfig = {\n            TWITTER_DRY_RUN:\n                parseBooleanFromText(\n                    runtime.getSetting(\"TWITTER_DRY_RUN\") ||\n                        process.env.TWITTER_DRY_RUN\n                ) ?? false, // parseBooleanFromText return null if \"\", map \"\" to false\n\n            TWITTER_APP_KEY: \n                runtime.getSetting(\"TWITTER_APP_KEY\") ||\n                process.env.TWITTER_APP_KEY,\n\n            TWITTER_APP_SECRET:\n                runtime.getSetting(\"TWITTER_APP_SECRET\") ||\n                process.env.TWITTER_APP_SECRET,\n\n            TWITTER_ACCESS_TOKEN:\n                runtime.getSetting(\"TWITTER_ACCESS_TOKEN\") ||\n                process.env.TWITTER_ACCESS_TOKEN,\n            \n            TWITTER_ACCESS_SECRET:\n                runtime.getSetting(\"TWITTER_ACCESS_SECRET\") ||\n                process.env.TWITTER_ACCESS_SECRET,\n\n            // number as string?\n            MAX_TWEET_LENGTH: safeParseInt(\n                runtime.getSetting(\"MAX_TWEET_LENGTH\") ||\n                    process.env.MAX_TWEET_LENGTH,\n                DEFAULT_MAX_TWEET_LENGTH\n            ),\n\n            TWITTER_SEARCH_ENABLE:\n                parseBooleanFromText(\n                    runtime.getSetting(\"TWITTER_SEARCH_ENABLE\") ||\n                        process.env.TWITTER_SEARCH_ENABLE\n                ) ?? false,\n\n            // string passthru\n            TWITTER_2FA_SECRET:\n                runtime.getSetting(\"TWITTER_2FA_SECRET\") ||\n                process.env.TWITTER_2FA_SECRET ||\n                \"\",\n\n            // int\n            TWITTER_RETRY_LIMIT: safeParseInt(\n                runtime.getSetting(\"TWITTER_RETRY_LIMIT\") ||\n                    process.env.TWITTER_RETRY_LIMIT,\n                5\n            ),\n\n            // int in seconds\n            TWITTER_POLL_INTERVAL: safeParseInt(\n                runtime.getSetting(\"TWITTER_POLL_INTERVAL\") ||\n                    process.env.TWITTER_POLL_INTERVAL,\n                120 // 2m\n            ),\n\n            // comma separated string\n            TWITTER_TARGET_USERS: parseTargetUsers(\n                runtime.getSetting(\"TWITTER_TARGET_USERS\") ||\n                    process.env.TWITTER_TARGET_USERS\n            ),\n\n            // bool\n            ENABLE_TWITTER_POST_GENERATION:\n                parseBooleanFromText(\n                    runtime.getSetting(\"ENABLE_TWITTER_POST_GENERATION\") ||\n                        process.env.ENABLE_TWITTER_POST_GENERATION\n                ) ?? true,\n\n\n            // int in minutes\n            POST_INTERVAL_MIN: safeParseInt(\n                runtime.getSetting(\"POST_INTERVAL_MIN\") ||\n                    process.env.POST_INTERVAL_MIN,\n                90 // 1.5 hours\n            ),\n\n            // int in minutes\n            POST_INTERVAL_MAX: safeParseInt(\n                runtime.getSetting(\"POST_INTERVAL_MAX\") ||\n                    process.env.POST_INTERVAL_MAX,\n                180 // 3 hours\n            ),\n\n            // bool\n            ENABLE_ACTION_PROCESSING:\n                parseBooleanFromText(\n                    runtime.getSetting(\"ENABLE_ACTION_PROCESSING\") ||\n                        process.env.ENABLE_ACTION_PROCESSING\n                ) ?? false,\n\n            // init in minutes (min 1m)\n            ACTION_INTERVAL: safeParseInt(\n                runtime.getSetting(\"ACTION_INTERVAL\") ||\n                    process.env.ACTION_INTERVAL,\n                5 // 5 minutes\n            ),\n\n            // bool\n            POST_IMMEDIATELY:\n                parseBooleanFromText(\n                    runtime.getSetting(\"POST_IMMEDIATELY\") ||\n                        process.env.POST_IMMEDIATELY\n                ) ?? false,\n\n            TWITTER_SPACES_ENABLE:\n                parseBooleanFromText(\n                    runtime.getSetting(\"TWITTER_SPACES_ENABLE\") ||\n                        process.env.TWITTER_SPACES_ENABLE\n                ) ?? false,\n\n            MAX_ACTIONS_PROCESSING: safeParseInt(\n                runtime.getSetting(\"MAX_ACTIONS_PROCESSING\") ||\n                    process.env.MAX_ACTIONS_PROCESSING,\n                1\n            ),\n\n            ACTION_TIMELINE_TYPE:\n                runtime.getSetting(\"ACTION_TIMELINE_TYPE\") ||\n                process.env.ACTION_TIMELINE_TYPE,\n        };\n\n        return twitterEnvSchema.parse(twitterConfig);\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `X/Twitter configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import { TweetV2 } from \"twitter-api-v2\";\nimport {\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    messageCompletionFooter,\n    shouldRespondFooter,\n    type Content,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    stringToUuid,\n    elizaLogger,\n    getEmbeddingZeroVector,\n    type IImageDescriptionService,\n    ServiceType\n} from \"@elizaos/core\";\nimport type { ClientBase } from \"./base\";\nimport { buildConversationThread, createElizaTweet, sendTweet, wait } from \"./utils.ts\";\nimport { ElizaTweet } from \"./types.ts\";\n\nexport const twitterMessageHandlerTemplate =\n    `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\n{{recentPosts}}\n\n# TASK: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\n\nCurrent Post:\n{{currentPost}}\nHere is the descriptions of images in the Current post.\n{{imageDescriptions}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n# INSTRUCTIONS: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\n{{actionNames}}\n{{actions}}\n\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)\n{{currentPost}}\nHere is the descriptions of images in the Current post.\n{{imageDescriptions}}\n` + messageCompletionFooter;\n\nexport const twitterShouldRespondTemplate = (targetUsersStr: string) =>\n    `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"true\" or \"false\".\n\nResponse options are RESPOND, IGNORE and STOP.\n\nPRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.\n\nFor other users:\n- {{agentName}} should RESPOND to messages directed at them\n- {{agentName}} should RESPOND to conversations relevant to their background\n- {{agentName}} should IGNORE irrelevant messages\n- {{agentName}} should IGNORE very short messages unless directly addressed\n- {{agentName}} should STOP if asked to stop\n- {{agentName}} should STOP if conversation is concluded\n- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.\n\nIMPORTANT:\n- {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\n- For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.\n\nRecent Posts:\n{{recentPosts}}\n\nCurrent Post:\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.\n` + shouldRespondFooter;\n\nexport class TwitterInteractionClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    private isDryRun: boolean;\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\n    }\n\n    async start() {\n        const handleTwitterInteractionsLoop = () => {\n            this.handleTwitterInteractions();\n            setTimeout(\n                handleTwitterInteractionsLoop,\n                // Defaults to 2 minutes\n                this.client.twitterConfig.TWITTER_POLL_INTERVAL * 1000\n            );\n        };\n        handleTwitterInteractionsLoop();\n    }\n\n    async handleTwitterInteractions() {\n        elizaLogger.log(\"Checking Twitter interactions\");\n\n        try {\n            // Check for mentions\n            const mentionCandidates: ElizaTweet[] = await this.client.getMentions(this.client.profile.id, 10);\n\n            elizaLogger.debug(`Fetched ${mentionCandidates.length} mentions`);\n            let uniqueTweetCandidates = [...mentionCandidates];\n            console.log(\"uniqueTweetCandidates:\");\n            console.dir(uniqueTweetCandidates, { depth: null });\n\n            // TODO: #TWITTER-V2-005 - Reimplement target users filtering using Twitter API v2\n            // const TARGET_USERS = this.client.twitterConfig.TWITTER_TARGET_USERS;            \n            // if (TARGET_USERS && TARGET_USERS.length > 0) {\n            //     elizaLogger.debug(\"Processing target users:\", TARGET_USERS);\n            //     // Create a map to store tweets by user\n            //     const tweetsByUser = new Map<string, Tweet[]>();\n\n            //     // Fetch tweets from all target users\n            //     for (const username of TARGET_USERS) {\n            //         try {\n            //             const userTweets = (\n            //                 await this.client.twitterClient.fetchSearchTweets(\n            //                     `from:${username}`,\n            //                     3,\n            //                     // SearchMode.Latest\n            //                 )\n            //             ).tweets;\n\n            //             // Filter for unprocessed, non-reply, recent tweets\n            //             const validTweets = userTweets.filter((tweet) => {\n            //                 const isUnprocessed =\n            //                     !this.client.lastCheckedTweetId ||\n            //                     Number.parseInt(tweet.id) >\n            //                         this.client.lastCheckedTweetId;\n            //                 const isRecent =\n            //                     Date.now() - tweet.timestamp * 1000 <\n            //                     2 * 60 * 60 * 1000;\n\n            //                 elizaLogger.log(`Tweet ${tweet.id} checks:`, {\n            //                     isUnprocessed,\n            //                     isRecent,\n            //                     isReply: tweet.isReply,\n            //                     isRetweet: tweet.isRetweet,\n            //                 });\n\n            //                 return (\n            //                     isUnprocessed &&\n            //                     !tweet.isReply &&\n            //                     !tweet.isRetweet &&\n            //                     isRecent\n            //                 );\n            //             });\n\n            //             if (validTweets.length > 0) {\n            //                 tweetsByUser.set(username, validTweets);\n            //                 elizaLogger.log(\n            //                     `Found ${validTweets.length} valid tweets from ${username}`\n            //                 );\n            //             }\n            //         } catch (error) {\n            //             elizaLogger.error(\n            //                 `Error fetching tweets for ${username}:`,\n            //                 error\n            //             );\n            //             continue;\n            //         }\n            //     }\n\n            //     // Select one tweet from each user that has tweets\n            //     const selectedTweets: Tweet[] = [];\n            //     for (const [username, tweets] of tweetsByUser) {\n            //         if (tweets.length > 0) {\n            //             // Randomly select one tweet from this user\n            //             const randomTweet =\n            //                 tweets[\n            //                     Math.floor(Math.random() * tweets.length)\n            //                 ];\n            //             selectedTweets.push(randomTweet);\n            //             elizaLogger.log(\n            //                 `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`\n            //             );\n            //         }\n            //     }\n\n            //     // Add selected tweets to candidates\n            //     uniqueTweetCandidates = [\n            //         ...mentionCandidates,\n            //         ...selectedTweets,\n            //     ];\n            // }\n\n            // Sort tweet candidates by ID in ascending order\n            uniqueTweetCandidates\n                .sort((a, b) => a.id.localeCompare(b.id))\n                .filter((tweet) => tweet.authorId !== this.client.profile.id);\n\n            // for each tweet candidate, handle the tweet\n            for (const tweet of uniqueTweetCandidates) {\n                if (\n                    !this.client.lastCheckedTweetId ||\n                    BigInt(tweet.id) > this.client.lastCheckedTweetId\n                ) {\n\n                    // Generate the tweetId UUID the same way it's done in handleTweet\n                    const tweetId = stringToUuid(`${tweet.id}-${this.runtime.agentId}`);\n\n                    // Check if we've already processed this tweet\n                    const existingResponse =\n                        await this.runtime.messageManager.getMemoryById(\n                            tweetId\n                        );\n                    if (existingResponse) {\n                        elizaLogger.log(\n                            `Already responded to tweet ${tweet.id}, skipping`\n                        );\n                        continue;\n                    }\n\n                    const roomId = stringToUuid(`${tweet.conversationId}-${this.runtime.agentId}`);\n\n                    const userIdUUID =\n                        tweet.authorId === this.client.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.authorId!);\n\n                    await this.runtime.ensureConnection(\n                        userIdUUID,\n                        roomId,\n                        tweet.authorUsername,\n                        tweet.authorName,\n                        \"twitter\"\n                    );\n\n                    const thread = await buildConversationThread(\n                        tweet,\n                        this.client\n                    );\n\n                    const message = {\n                        content: { \n                            text: tweet.text,\n                            imageUrls: tweet.photos?.map(photo => photo.url) || []\n                        },\n                        agentId: this.runtime.agentId,\n                        userId: userIdUUID,\n                        roomId,\n                    };\n\n                    await this.handleTweet({\n                        tweet,\n                        message,\n                        thread,\n                    });\n\n                    // Update the last checked tweet ID after processing each tweet\n                    this.client.lastCheckedTweetId = BigInt(tweet.id);\n                }\n            }\n\n            // Save the latest checked tweet ID to the file\n            await this.client.cacheLatestCheckedTweetId();\n\n            elizaLogger.log(\"Finished checking Twitter interactions\");\n        } catch (error) {\n            console.error(error);\n            elizaLogger.error(\"Error handling Twitter interactions:\", error);\n        }\n    }\n\n    private async handleTweet({\n        tweet,\n        message,\n        thread,\n    }: {\n        tweet: ElizaTweet;\n        message: Memory;\n        thread: ElizaTweet[];\n    }) {\n        // Only skip if tweet is from self AND not from a target user\n        if (tweet.authorId === this.client.profile.id &&\n            !this.client.twitterConfig.TWITTER_TARGET_USERS.includes(tweet.authorUsername)) {\n            return;\n        }\n\n        if (!message.content.text) {\n            elizaLogger.log(\"Skipping Tweet with no text\", tweet.id);\n            return { text: \"\", action: \"IGNORE\" };\n        }\n\n        elizaLogger.log(\"Processing Tweet: \", tweet.id);\n        const formatTweet = (tweet: ElizaTweet) => {\n            return `ID: ${tweet.id}\\nFrom: ${tweet.authorName} (@${tweet.authorUsername})\\nText: ${tweet.text}`;\n        };\n        const currentPost = formatTweet(tweet);\n\n        const formattedConversation = thread\n            .map(\n                (tweet) => `@${tweet.authorUsername} (${new Date(\n                    tweet.timestamp * 1000\n                ).toLocaleString(\"en-US\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\", \n                    month: \"short\",\n                    day: \"numeric\",\n                })}):\n                ${tweet.text}`\n            )\n            .join(\"\\n\\n\");\n\n        const imageDescriptionsArray = [];\n        try {\n            for (const photo of tweet.photos) {\n                const description = await this.runtime\n                    .getService<IImageDescriptionService>(\n                        ServiceType.IMAGE_DESCRIPTION\n                    )\n                    .describeImage(photo.url);\n                imageDescriptionsArray.push(description);\n            }\n        } catch (error) {\n            // Handle the error\n            elizaLogger.error(\"Error Occured during describing image: \", error);\n        }\n\n        // compose the state\n        let state = await this.runtime.composeState(message, {\n            twitterClient: this.client.twitterClient,\n            twitterUserName: this.client.profile.username,\n            currentPost,\n            formattedConversation,\n            imageDescriptions: imageDescriptionsArray.length > 0\n                ? `\\nImages in Tweet:\\n${imageDescriptionsArray.map((desc, i) =>\n                    `Image ${i + 1}: Title: ${desc.title}\\nDescription: ${desc.description}`).join(\"\\n\\n\")}`\n                : \"\",\n        });\n\n        // check if the tweet exists, save if it doesn't\n        const tweetId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n        const tweetExists =\n            await this.runtime.messageManager.getMemoryById(tweetId);\n\n        if (!tweetExists) {\n            elizaLogger.log(\"tweet does not exist, saving\");\n            const userIdUUID = stringToUuid(tweet.authorId as string);\n            const roomId = stringToUuid(tweet.conversationId);\n\n            const message = {\n                id: tweetId,\n                agentId: this.runtime.agentId,\n                content: {\n                    text: tweet.text,\n                    url: tweet.permanentUrl,\n                    imageUrls: tweet.photos?.map(photo => photo.url) || [],\n                    inReplyTo: tweet.inReplyToStatusId\n                        ? stringToUuid(\n                              tweet.inReplyToStatusId +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n                },\n                userId: userIdUUID,\n                roomId,\n                createdAt: tweet.timestamp * 1000,\n            };\n            this.client.saveRequestMessage(message, state);\n        }\n\n        // get usernames into str\n        const validTargetUsersStr =\n            this.client.twitterConfig.TWITTER_TARGET_USERS.join(\",\");\n\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates\n                    ?.twitterShouldRespondTemplate ||\n                this.runtime.character?.templates?.shouldRespondTemplate ||\n                twitterShouldRespondTemplate(validTargetUsersStr),\n        });\n\n        const shouldRespond = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.MEDIUM,\n        });\n\n        // Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\n        if (shouldRespond !== \"RESPOND\") {\n            elizaLogger.log(\"Not responding to message\");\n            return { text: \"Response Decision:\", action: shouldRespond };\n        }\n\n        const context = composeContext({\n            state: {\n                ...state,\n                // Convert actionNames array to string\n                actionNames: Array.isArray(state.actionNames)\n                    ? state.actionNames.join(', ')\n                    : state.actionNames || '',\n                actions: Array.isArray(state.actions)\n                    ? state.actions.join('\\n')\n                    : state.actions || '',\n                // Ensure character examples are included\n                characterPostExamples: this.runtime.character.messageExamples\n                    ? this.runtime.character.messageExamples\n                        .map(example =>\n                            example.map(msg =>\n                                `${msg.user}: ${msg.content.text}${msg.content.action ? ` [Action: ${msg.content.action}]` : ''}`\n                            ).join('\\n')\n                        ).join('\\n\\n')\n                    : '',\n            },\n            template:\n                this.runtime.character.templates\n                    ?.twitterMessageHandlerTemplate ||\n                this.runtime.character?.templates?.messageHandlerTemplate ||\n                twitterMessageHandlerTemplate,\n        });\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n\n        const removeQuotes = (str: string) =>\n            str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n        const stringId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n\n        response.inReplyTo = stringId;\n\n        response.text = removeQuotes(response.text);\n\n        if (response.text) {\n            if (this.isDryRun) {\n                elizaLogger.info(\n                    `Dry run: Selected Post: ${tweet.id} - ${tweet.authorUsername}: ${tweet.text}\\nAgent's Output:\\n${response.text}`\n                );\n            } else {\n                try {\n                    const callback: HandlerCallback = async (\n                        response: Content,\n                        tweetId?: string\n                    ) => {\n                        const memories = await sendTweet(\n                            this.client,\n                            response,\n                            message.roomId,\n                            this.client.profile.username,\n                            tweetId || tweet.id\n                        );\n                        return memories;\n                    };\n\n                    const action = this.runtime.actions.find((a) => a.name === response.action);\n                    const shouldSuppressInitialMessage = action?.suppressInitialMessage;\n\n                    let responseMessages = [];\n\n                    if (!shouldSuppressInitialMessage) {\n                        responseMessages = await callback(response);\n                    } else {\n                        responseMessages = [{\n                            id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                            userId: this.runtime.agentId,\n                            agentId: this.runtime.agentId,\n                            content: response,\n                            roomId: message.roomId,\n                            embedding: getEmbeddingZeroVector(),\n                            createdAt: Date.now(),\n                        }];\n                    }\n\n                    state = (await this.runtime.updateRecentMessageState(\n                        state\n                    )) as State;\n\n                    for (const responseMessage of responseMessages) {\n                        if (\n                            responseMessage ===\n                            responseMessages[responseMessages.length - 1]\n                        ) {\n                            responseMessage.content.action = response.action;\n                        } else {\n                            responseMessage.content.action = \"CONTINUE\";\n                        }\n                        await this.runtime.messageManager.createMemory(\n                            responseMessage\n                        );\n                    }\n\n                    const responseTweetId =\n                    responseMessages[responseMessages.length - 1]?.content\n                        ?.tweetId;\n\n                    await this.runtime.processActions(\n                        message,\n                        responseMessages,\n                        state,\n                        (response: Content) => {\n                            return callback(response, responseTweetId);\n                        }\n                    );\n\n                    const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${tweet.id} - @${tweet.authorUsername}: ${tweet.text}\\nAgent's Output:\\n${response.text}`;\n\n                    await this.runtime.cacheManager.set(\n                        `twitter/tweet_generation_${tweet.id}.txt`,\n                        responseInfo\n                    );\n                    await wait();\n                } catch (error) {\n                    elizaLogger.error(`Error sending response tweet: ${error}`);\n                }\n            }\n        }\n    }\n\n}","import { \n    SendTweetV2Params, \n    TweetV2PostTweetResult, \n    TweetV2SingleResult,\n    TwitterV2IncludesHelper \n} from \"twitter-api-v2\";\nimport {\n    composeContext,\n    generateText,\n    getEmbeddingZeroVector,\n    type IAgentRuntime,\n    ModelClass,\n    stringToUuid,\n    type TemplateType,\n    type UUID,\n    truncateToCompleteSentence,\n    parseJSONObjectFromText,\n    extractAttributes,\n    cleanJsonResponse,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport { postActionResponseFooter } from \"@elizaos/core\";\nimport { generateTweetActions } from \"@elizaos/core\";\nimport { type IImageDescriptionService, ServiceType } from \"@elizaos/core\";\nimport { ClientBase } from \"./base.ts\";\nimport { buildConversationThread, fetchMediaData, createElizaTweet } from \"./utils.ts\";\nimport { twitterMessageHandlerTemplate } from \"./interactions.ts\";\nimport { DEFAULT_MAX_TWEET_LENGTH } from \"./environment.ts\";\nimport {\n    Client,\n    Events,\n    GatewayIntentBits,\n    TextChannel,\n    Partials,\n} from \"discord.js\";\nimport type { State } from \"@elizaos/core\";\nimport type { ActionResponse } from \"@elizaos/core\";\nimport type { ElizaTweet, MediaData } from \"./types.ts\";\n\nconst MAX_TIMELINES_TO_FETCH = 15;\n\nconst twitterPostTemplate = `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\n# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should be 1, 2, or 3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\\\n\\\\n (double spaces) between statements if there are multiple statements in your response.`;\n\nexport const twitterActionTemplate =\n    `\n# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:\n{{bio}}\n{{postDirections}}\n\nGuidelines:\n- ONLY engage with content that DIRECTLY relates to character's core interests\n- Direct mentions are priority IF they are on-topic\n- Skip ALL content that is:\n  - Off-topic or tangentially related\n  - From high-profile accounts unless explicitly relevant\n  - Generic/viral content without specific relevance\n  - Political/controversial unless central to character\n  - Promotional/marketing unless directly relevant\n\nActions (respond only with tags):\n[LIKE] - Perfect topic match AND aligns with character (9.8/10)\n[RETWEET] - Exceptional content that embodies character's expertise (9.5/10)\n[QUOTE] - Can add substantial domain expertise (9.5/10)\n[REPLY] - Can contribute meaningful, expert-level insight (9.5/10)\n\nTweet:\n{{currentTweet}}\n\n# Respond with qualifying action tags only. Default to NO action unless extremely confident of relevance.` +\n    postActionResponseFooter;\n\ninterface PendingTweet {\n    tweetTextForPosting: string;\n    roomId: UUID;\n    rawTweetContent: string;\n    discordMessageId: string;\n    channelId: string;\n    timestamp: number;\n}\n\ntype PendingTweetApprovalStatus = \"PENDING\" | \"APPROVED\" | \"REJECTED\";\n\nexport class TwitterPostClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    twitterUsername: string;\n    private isProcessing = false;\n    private lastProcessTime = 0;\n    private stopProcessingActions = false;\n    private isDryRun: boolean;\n    private discordClientForApproval: Client;\n    private approvalRequired = false;\n    private discordApprovalChannelId: string;\n    private approvalCheckInterval: number;\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\n\n        // Log configuration on initialization\n        elizaLogger.log(\"Twitter Client Configuration:\");\n        elizaLogger.log(`- Username: ${this.client.profile?.username}`);\n        elizaLogger.log(\n            `- Dry Run Mode: ${this.isDryRun ? \"enabled\" : \"disabled\"}`\n        );\n\n        elizaLogger.log(\n            `- Enable Post: ${this.client.twitterConfig.ENABLE_TWITTER_POST_GENERATION ? \"enabled\" : \"disabled\"}`\n        );\n\n        elizaLogger.log(\n            `- Post Interval: ${this.client.twitterConfig.POST_INTERVAL_MIN}-${this.client.twitterConfig.POST_INTERVAL_MAX} minutes`\n        );\n        elizaLogger.log(\n            `- Action Processing: ${\n                this.client.twitterConfig.ENABLE_ACTION_PROCESSING\n                    ? \"enabled\"\n                    : \"disabled\"\n            }`\n        );\n        elizaLogger.log(\n            `- Action Interval: ${this.client.twitterConfig.ACTION_INTERVAL} minutes`\n        );\n        elizaLogger.log(\n            `- Post Immediately: ${\n                this.client.twitterConfig.POST_IMMEDIATELY\n                    ? \"enabled\"\n                    : \"disabled\"\n            }`\n        );\n        elizaLogger.log(\n            `- Search Enabled: ${\n                this.client.twitterConfig.TWITTER_SEARCH_ENABLE\n                    ? \"enabled\"\n                    : \"disabled\"\n            }`\n        );\n\n        const targetUsers = this.client.twitterConfig.TWITTER_TARGET_USERS;\n        if (targetUsers) {\n            elizaLogger.log(`- Target Users: ${targetUsers}`);\n        }\n\n        if (this.isDryRun) {\n            elizaLogger.log(\n                \"Twitter client initialized in dry run mode - no actual tweets should be posted\"\n            );\n        }\n\n        // Initialize Discord webhook\n        const approvalRequired: boolean =\n            this.runtime\n                .getSetting(\"TWITTER_APPROVAL_ENABLED\")\n                ?.toLocaleLowerCase() === \"true\";\n        if (approvalRequired) {\n            const discordToken = this.runtime.getSetting(\n                \"TWITTER_APPROVAL_DISCORD_BOT_TOKEN\"\n            );\n            const approvalChannelId = this.runtime.getSetting(\n                \"TWITTER_APPROVAL_DISCORD_CHANNEL_ID\"\n            );\n\n            const APPROVAL_CHECK_INTERVAL =\n                Number.parseInt(\n                    this.runtime.getSetting(\"TWITTER_APPROVAL_CHECK_INTERVAL\")\n                ) || 5 * 60 * 1000; // 5 minutes\n\n            this.approvalCheckInterval = APPROVAL_CHECK_INTERVAL;\n\n            if (!discordToken || !approvalChannelId) {\n                throw new Error(\n                    \"TWITTER_APPROVAL_DISCORD_BOT_TOKEN and TWITTER_APPROVAL_DISCORD_CHANNEL_ID are required for approval workflow\"\n                );\n            }\n\n            this.approvalRequired = true;\n            this.discordApprovalChannelId = approvalChannelId;\n\n            // Set up Discord client event handlers\n            this.setupDiscordClient();\n        }\n    }\n\n    private setupDiscordClient() {\n        this.discordClientForApproval = new Client({\n            intents: [\n                GatewayIntentBits.Guilds,\n                GatewayIntentBits.GuildMessages,\n                GatewayIntentBits.MessageContent,\n                GatewayIntentBits.GuildMessageReactions,\n            ],\n            partials: [Partials.Channel, Partials.Message, Partials.Reaction],\n        });\n        this.discordClientForApproval.once(\n            Events.ClientReady,\n            (readyClient) => {\n                elizaLogger.log(\n                    `Discord bot is ready as ${readyClient.user.tag}!`\n                );\n\n                // Generate invite link with required permissions\n                const invite = `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user.id}&permissions=274877991936&scope=bot`;\n                // 274877991936 includes permissions for:\n                // - Send Messages\n                // - Read Messages/View Channels\n                // - Read Message History\n\n                elizaLogger.log(\n                    `Use this link to properly invite the Twitter Post Approval Discord bot: ${invite}`\n                );\n            }\n        );\n        // Login to Discord\n        this.discordClientForApproval.login(\n            this.runtime.getSetting(\"TWITTER_APPROVAL_DISCORD_BOT_TOKEN\")\n        );\n    }\n\n    async start() {\n        if (!this.client.profile.username) {\n            await this.client.init();\n        }\n\n        const generateNewTweetLoop = async () => {\n            const lastPost = await this.runtime.cacheManager.get<{\n                timestamp: number;\n            }>(\"twitter/\" + this.client.profile.username + \"/lastPost\");\n\n            const lastPostTimestamp = lastPost?.timestamp ?? 0;\n            elizaLogger.debug(`Last post timestamp: ${lastPostTimestamp}`);\n            const minMinutes: number = this.client.twitterConfig.POST_INTERVAL_MIN as number;\n            const maxMinutes: number = this.client.twitterConfig.POST_INTERVAL_MAX as number;\n            const randomMinutes =\n                Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) + minMinutes;\n            const delay = randomMinutes * 60 * 1000;\n\n            // Calculate time since last post\n            const timeSinceLastPost = Date.now() - new Date(lastPostTimestamp).getTime();\n            \n            if (timeSinceLastPost >= delay) {\n                elizaLogger.debug(`Time since last post: ${timeSinceLastPost}ms, generating new tweet`);\n                await this.generateNewTweet();\n                // After posting, schedule next check with new random delay\n                setTimeout(() => {\n                    generateNewTweetLoop();\n                }, randomMinutes * 60 * 1000);\n            } else {\n                // If not enough time has passed, schedule next check for remaining time\n                const remainingDelay = delay - timeSinceLastPost;\n                elizaLogger.debug(`Time since last post: ${timeSinceLastPost}ms, next check in ${remainingDelay}ms`);\n                setTimeout(() => {\n                    generateNewTweetLoop();\n                }, remainingDelay);\n            }\n\n            elizaLogger.log(`Next tweet scheduled in ${randomMinutes} minutes`);\n        };\n\n        // TODO: #TWITTER-V2-008 - Reimplement action processing using Twitter API v2\n        // const processActionsLoop = async () => {\n        //     const actionInterval = this.client.twitterConfig.ACTION_INTERVAL; // Defaults to 5 minutes\n\n        //     while (!this.stopProcessingActions) {\n        //         try {\n        //             const results = await this.processTweetActions();\n        //             if (results) {\n        //                 elizaLogger.log(`Processed ${results.length} tweets`);\n        //                 elizaLogger.log(\n        //                     `Next action processing scheduled in ${actionInterval} minutes`\n        //                 );\n        //                 // Wait for the full interval before next processing\n        //                 await new Promise(\n        //                     (resolve) =>\n        //                         setTimeout(resolve, actionInterval * 60 * 1000) // now in minutes\n        //                 );\n        //             }\n        //         } catch (error) {\n        //             elizaLogger.error(\n        //                 \"Error in action processing loop:\",\n        //                 error\n        //             );\n        //             // Add exponential backoff on error\n        //             await new Promise((resolve) => setTimeout(resolve, 30000)); // Wait 30s on error\n        //         }\n        //     }\n        // };\n\n        if (this.client.twitterConfig.POST_IMMEDIATELY) {\n            await this.generateNewTweet();\n        }\n\n        if (this.client.twitterConfig.ENABLE_TWITTER_POST_GENERATION) {\n            generateNewTweetLoop();\n            elizaLogger.log(\"Tweet generation loop started\");\n        }\n\n        // TODO: #TWITTER-V2-008 - Reimplement action processing using Twitter API v2\n        // if (this.client.twitterConfig.ENABLE_ACTION_PROCESSING) {\n        //     processActionsLoop().catch((error) => {\n        //         elizaLogger.error(\n        //             \"Fatal error in process actions loop:\",\n        //             error\n        //         );\n        //     });\n        // }\n\n        if (this.approvalRequired) this.runPendingTweetCheckLoop();\n    }\n\n    private runPendingTweetCheckLoop() {\n        setInterval(async () => {\n            await this.handlePendingTweet();\n        }, this.approvalCheckInterval);\n    }\n\n    async processAndCacheTweet(\n        runtime: IAgentRuntime,\n        client: ClientBase,\n        tweet: ElizaTweet,\n        roomId: UUID,\n        rawTweetContent: string\n    ) {\n        // Cache the last post details\n        await runtime.cacheManager.set(\n            `twitter/${client.profile.username}/lastPost`,\n            {\n                id: tweet.id,\n                timestamp: tweet.timestamp,\n            }\n        );\n\n        // Cache the tweet\n        await client.cacheTweet(tweet);\n\n        // Log the posted tweet\n        elizaLogger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\n\n        // Ensure the room and participant exist\n        await runtime.ensureRoomExists(roomId);\n        await runtime.ensureParticipantInRoom(runtime.agentId, roomId);\n\n        // Create a memory for the tweet\n        await runtime.messageManager.createMemory({\n            id: stringToUuid(tweet.id + \"-\" + runtime.agentId),\n            userId: runtime.agentId,\n            agentId: runtime.agentId,\n            content: {\n                text: rawTweetContent.trim(),\n                url: tweet.permanentUrl,\n                source: \"twitter\",\n            },\n            roomId,\n            embedding: getEmbeddingZeroVector(),\n            createdAt: tweet.timestamp,\n        });\n    }\n\n    // TODO: #TWITTER-V2-006 - Reimplement note tweet handling using Twitter API v2\n    // async handleNoteTweet(\n    //     client: ClientBase,\n    //     content: string,\n    //     tweetId?: string,\n    //     mediaData?: MediaData[]\n    // ) {\n    //     try {\n    //         const noteTweetResult = await client.requestQueue.add(\n    //             async () =>\n    //                 await client.twitterClient.sendNoteTweet(\n    //                     content,\n    //                     tweetId,\n    //                     mediaData\n    //                 )\n    //         );\n\n    //         if (noteTweetResult.errors && noteTweetResult.errors.length > 0) {\n    //             // Note Tweet failed due to authorization. Falling back to standard Tweet.\n    //             const truncateContent = truncateToCompleteSentence(\n    //                 content,\n    //                 this.client.twitterConfig.MAX_TWEET_LENGTH\n    //             );\n    //             return await this.sendStandardTweet(\n    //                 client,\n    //                 truncateContent,\n    //                 tweetId\n    //             );\n    //         } else {\n    //             return noteTweetResult.data.notetweet_create.tweet_results\n    //                 .result;\n    //         }\n    //     } catch (error) {\n    //         throw new Error(`Note Tweet failed: ${error}`);\n    //     }\n    // }\n\n    async sendStandardTweet(\n        client: ClientBase,\n        content: string,\n        tweetId?: string,\n        mediaData?: MediaData[]\n    ) {\n        try {\n            const standardTweetResult: TweetV2PostTweetResult = await client.requestQueue.add(\n                async () => {\n                    const payload: SendTweetV2Params = {\n                        text: content,\n                    }\n                    const result = await client.twitterClient.v2.tweet(payload)\n                    return result;\n                }\n            );\n            if (!standardTweetResult.data) {\n                elizaLogger.error(\"Error sending tweet; Bad response:\", standardTweetResult);\n                return;\n            }\n            return standardTweetResult.data;\n        } catch (error) {\n            elizaLogger.error(\"Error sending standard Tweet:\", error);\n            throw error;\n        }\n    }\n\n    async postTweet(\n        runtime: IAgentRuntime,\n        client: ClientBase,\n        tweetTextForPosting: string,\n        roomId: UUID,\n        rawTweetContent: string,\n        twitterUsername: string,\n        mediaData?: MediaData[]\n    ) {\n        try {\n            elizaLogger.log(`Posting new tweet:\\n`);\n\n            let result;\n\n            // TODO: #TWITTER-V2-006 - Reimplement note tweet handling using Twitter API v2\n            if (tweetTextForPosting.length > DEFAULT_MAX_TWEET_LENGTH) {\n                elizaLogger.error(\"must reimplement note tweets using twitter v2 api\")\n                // result = await this.handleNoteTweet(\n                //     client,\n                //     tweetTextForPosting,\n                //     undefined,\n                //     mediaData\n                // );\n            } else {\n                result = await this.sendStandardTweet(\n                    client,\n                    tweetTextForPosting,\n                    undefined,\n                    mediaData\n                );\n            }\n            \n            // look up the tweet and populate the tweet object\n            const fetchedTweet: TweetV2SingleResult = await this.client.requestQueue.add(\n                async () =>\n                    await client.twitterClient.v2.singleTweet(result.id, {\n                        \"tweet.fields\": \"created_at,author_id,conversation_id,entities,referenced_tweets,text\",\n                        \"expansions\": \"author_id,referenced_tweets.id\"\n                    })\n            );\n\n            const tweet = createElizaTweet(\n                fetchedTweet.data,\n                new TwitterV2IncludesHelper(fetchedTweet)\n            );\n\n            await this.processAndCacheTweet(\n                runtime,\n                client,\n                tweet,\n                roomId,\n                rawTweetContent\n            );\n        } catch (error) {\n            console.error(error);\n            elizaLogger.error(\"Error sending tweet:\", error);\n        }\n    }\n\n    /**\n     * Generates and posts a new tweet. If isDryRun is true, only logs what would have been posted.\n     */\n    async generateNewTweet() {\n        elizaLogger.log(\"Generating new tweet\");\n\n        try {\n            const roomId = stringToUuid(\n                \"twitter_generate_room-\" + this.client.profile.username\n            );\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.client.profile.username,\n                this.runtime.character.name,\n                \"twitter\"\n            );\n\n            const topics = this.runtime.character.topics.join(\", \");\n            const maxTweetLength = this.client.twitterConfig.MAX_TWEET_LENGTH;\n            const state = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: roomId,\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: topics || \"\",\n                        action: \"TWEET\",\n                    },\n                },\n                {\n                    twitterUserName: this.client.profile.username,\n                    maxTweetLength,\n                }\n            );\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.twitterPostTemplate ||\n                    twitterPostTemplate,\n            });\n\n            elizaLogger.debug(\"generate post prompt:\\n\" + context);\n\n            const response = await generateText({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            const rawTweetContent = cleanJsonResponse(response);\n\n            // First attempt to clean content\n            let tweetTextForPosting = null;\n            let mediaData = null;\n\n            // Try parsing as JSON first\n            const parsedResponse = parseJSONObjectFromText(rawTweetContent);\n            if (parsedResponse?.text) {\n                tweetTextForPosting = parsedResponse.text;\n            } else {\n                // If not JSON, use the raw text directly\n                tweetTextForPosting = rawTweetContent.trim();\n            }\n\n            if (\n                parsedResponse?.attachments &&\n                parsedResponse?.attachments.length > 0\n            ) {\n                mediaData = await fetchMediaData(parsedResponse.attachments);\n            }\n\n            // Try extracting text attribute\n            if (!tweetTextForPosting) {\n                const parsingText = extractAttributes(rawTweetContent, [\n                    \"text\",\n                ]).text;\n                if (parsingText) {\n                    tweetTextForPosting = truncateToCompleteSentence(\n                        extractAttributes(rawTweetContent, [\"text\"]).text,\n                        this.client.twitterConfig.MAX_TWEET_LENGTH\n                    );\n                }\n            }\n\n            // Use the raw text\n            if (!tweetTextForPosting) {\n                tweetTextForPosting = rawTweetContent;\n            }\n\n            // Truncate the content to the maximum tweet length specified in the environment settings, ensuring the truncation respects sentence boundaries.\n            if (maxTweetLength) {\n                tweetTextForPosting = truncateToCompleteSentence(\n                    tweetTextForPosting,\n                    maxTweetLength\n                );\n            }\n\n            const removeQuotes = (str: string) =>\n                str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n            const fixNewLines = (str: string) => str.replaceAll(/\\\\n/g, \"\\n\\n\"); //ensures double spaces\n\n            // Final cleaning\n            tweetTextForPosting = removeQuotes(\n                fixNewLines(tweetTextForPosting)\n            );\n\n            if (this.isDryRun) {\n                elizaLogger.info(\n                    `Dry run: would have posted tweet: ${tweetTextForPosting}`\n                );\n                return;\n            }\n\n            try {\n                if (this.approvalRequired) {\n                    // Send for approval instead of posting directly\n                    elizaLogger.log(\n                        `Sending Tweet For Approval:\\n ${tweetTextForPosting}`\n                    );\n                    // await this.sendForApproval(\n                    //     tweetTextForPosting,\n                    //     roomId,\n                    //     rawTweetContent\n                    // );\n                    elizaLogger.log(\"Tweet sent for approval\");\n                } else {\n                    elizaLogger.log(\n                        `Posting new tweet:\\n ${tweetTextForPosting}`\n                    );\n                    this.postTweet(\n                        this.runtime,\n                        this.client,\n                        tweetTextForPosting,\n                        roomId,\n                        rawTweetContent,\n                        this.client.profile.username,\n                        mediaData\n                    );\n                }\n            } catch (error) {\n                elizaLogger.error(\"Error sending tweet:\", error);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error generating new tweet:\", error);\n        }\n    }\n\n    private async generateTweetContent(\n        tweetState: any,\n        options?: {\n            template?: TemplateType;\n            context?: string;\n        }\n    ): Promise<string> {\n        const context = composeContext({\n            state: tweetState,\n            template:\n                options?.template ||\n                this.runtime.character.templates?.twitterPostTemplate ||\n                twitterPostTemplate,\n        });\n\n        const response = await generateText({\n            runtime: this.runtime,\n            context: options?.context || context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        elizaLogger.log(\"generate tweet content response:\\n\" + response);\n\n        // First clean up any markdown and newlines\n        const cleanedResponse = cleanJsonResponse(response);\n\n        // Try to parse as JSON first\n        const jsonResponse = parseJSONObjectFromText(cleanedResponse);\n        if (jsonResponse.text) {\n            const truncateContent = truncateToCompleteSentence(\n                jsonResponse.text,\n                this.client.twitterConfig.MAX_TWEET_LENGTH\n            );\n            return truncateContent;\n        }\n        if (typeof jsonResponse === \"object\") {\n            const possibleContent =\n                jsonResponse.content ||\n                jsonResponse.message ||\n                jsonResponse.response;\n            if (possibleContent) {\n                const truncateContent = truncateToCompleteSentence(\n                    possibleContent,\n                    this.client.twitterConfig.MAX_TWEET_LENGTH\n                );\n                return truncateContent;\n            }\n        }\n\n        let truncateContent = null;\n        // Try extracting text attribute\n        const parsingText = extractAttributes(cleanedResponse, [\"text\"]).text;\n        if (parsingText) {\n            truncateContent = truncateToCompleteSentence(\n                parsingText,\n                this.client.twitterConfig.MAX_TWEET_LENGTH\n            );\n        }\n\n        if (!truncateContent) {\n            // If not JSON or no valid content found, clean the raw text\n            truncateContent = truncateToCompleteSentence(\n                cleanedResponse,\n                this.client.twitterConfig.MAX_TWEET_LENGTH\n            );\n        }\n\n        return truncateContent;\n    }\n\n    // TODO: #TWITTER-V2-008 - Reimplement action processing using Twitter API v2\n    /**\n     * Processes tweet actions (likes, retweets, quotes, replies). If isDryRun is true,\n     * only simulates and logs actions without making API calls.\n     */\n    // private async processTweetActions() {\n    //     if (this.isProcessing) {\n    //         elizaLogger.log(\"Already processing tweet actions, skipping\");\n    //         return null;\n    //     }\n\n    //     try {\n    //         this.isProcessing = true;\n    //         this.lastProcessTime = Date.now();\n\n    //         elizaLogger.log(\"Processing tweet actions\");\n\n    //         await this.runtime.ensureUserExists(\n    //             this.runtime.agentId,\n    //             this.client.profile.username,\n    //             this.runtime.character.name,\n    //             \"twitter\"\n    //         );\n\n    //         const timelines = await this.client.fetchTimelineForActions(\n    //             MAX_TIMELINES_TO_FETCH\n    //         );\n    //         const maxActionsProcessing =\n    //             this.client.twitterConfig.MAX_ACTIONS_PROCESSING;\n    //         const processedTimelines = [];\n\n    //         for (const tweet of timelines) {\n    //             try {\n    //                 // Skip if we've already processed this tweet\n    //                 const memory =\n    //                     await this.runtime.messageManager.getMemoryById(\n    //                         stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n    //                     );\n    //                 if (memory) {\n    //                     elizaLogger.log(\n    //                         `Already processed tweet ID: ${tweet.id}`\n    //                     );\n    //                     continue;\n    //                 }\n\n    //                 const roomId = stringToUuid(\n    //                     tweet.conversationId + \"-\" + this.runtime.agentId\n    //                 );\n\n    //                 const tweetState = await this.runtime.composeState(\n    //                     {\n    //                         userId: this.runtime.agentId,\n    //                         roomId,\n    //                         agentId: this.runtime.agentId,\n    //                         content: { text: \"\", action: \"\" },\n    //                     },\n    //                     {\n    //                         twitterUserName: this.client.profile.username,\n    //                         currentTweet: `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})\\nText: ${tweet.text}`,\n    //                     }\n    //                 );\n\n    //                 const actionContext = composeContext({\n    //                     state: tweetState,\n    //                     template:\n    //                         this.runtime.character.templates\n    //                             ?.twitterActionTemplate ||\n    //                         twitterActionTemplate,\n    //                 });\n\n    //                 const actionResponse = await generateTweetActions({\n    //                     runtime: this.runtime,\n    //                     context: actionContext,\n    //                     modelClass: ModelClass.SMALL,\n    //                 });\n\n    //                 if (!actionResponse) {\n    //                     elizaLogger.log(\n    //                         `No valid actions generated for tweet ${tweet.id}`\n    //                     );\n    //                     continue;\n    //                 }\n    //                 processedTimelines.push({\n    //                     tweet: tweet,\n    //                     actionResponse: actionResponse,\n    //                     tweetState: tweetState,\n    //                     roomId: roomId,\n    //                 });\n    //             } catch (error) {\n    //                 elizaLogger.error(\n    //                     `Error processing tweet ${tweet.id}:`,\n    //                     error\n    //                 );\n    //                 continue;\n    //             }\n    //         }\n\n    //         const sortProcessedTimeline = (arr: typeof processedTimelines) => {\n    //             return arr.sort((a, b) => {\n    //                 // Count the number of true values in the actionResponse object\n    //                 const countTrue = (obj: typeof a.actionResponse) =>\n    //                     Object.values(obj).filter(Boolean).length;\n\n    //                 const countA = countTrue(a.actionResponse);\n    //                 const countB = countTrue(b.actionResponse);\n\n    //                 // Primary sort by number of true values\n    //                 if (countA !== countB) {\n    //                     return countB - countA;\n    //                 }\n\n    //                 // Secondary sort by the \"like\" property\n    //                 if (a.actionResponse.like !== b.actionResponse.like) {\n    //                     return a.actionResponse.like ? -1 : 1;\n    //                 }\n\n    //                 // Tertiary sort keeps the remaining objects with equal weight\n    //                 return 0;\n    //             });\n    //         };\n    //         // Sort the timeline based on the action decision score,\n    //         // then slice the results according to the environment variable to limit the number of actions per cycle.\n    //         const sortedTimelines = sortProcessedTimeline(\n    //             processedTimelines\n    //         ).slice(0, maxActionsProcessing);\n\n    //         return this.processTimelineActions(sortedTimelines); // Return results array to indicate completion\n    //     } catch (error) {\n    //         elizaLogger.error(\"Error in processTweetActions:\", error);\n    //         throw error;\n    //     } finally {\n    //         this.isProcessing = false;\n    //     }\n    // }\n\n    // TODO: #TWITTER-V2-008 - Reimplement action processing using Twitter API v2\n    /**\n     * Processes a list of timelines by executing the corresponding tweet actions.\n     * Each timeline includes the tweet, action response, tweet state, and room context.\n     * Results are returned for tracking completed actions.\n     *\n     * @param timelines - Array of objects containing tweet details, action responses, and state information.\n     * @returns A promise that resolves to an array of results with details of executed actions.\n     */\n    // private async processTimelineActions(\n    //     timelines: {\n    //         tweet: Tweet;\n    //         actionResponse: ActionResponse;\n    //         tweetState: State;\n    //         roomId: UUID;\n    //     }[]\n    // ): Promise<\n    //     {\n    //         tweetId: string;\n    //         actionResponse: ActionResponse;\n    //         executedActions: string[];\n    //     }[]\n    // > {\n    //     const results = [];\n    //     for (const timeline of timelines) {\n    //         const { actionResponse, tweetState, roomId, tweet } = timeline;\n    //         try {\n    //             const executedActions: string[] = [];\n    //             // Execute actions\n    //             if (actionResponse.like) {\n    //                 if (this.isDryRun) {\n    //                     elizaLogger.info(\n    //                         `Dry run: would have liked tweet ${tweet.id}`\n    //                     );\n    //                     executedActions.push(\"like (dry run)\");\n    //                 } else {\n    //                     try {\n    //                         await this.client.twitterClient.likeTweet(tweet.id);\n    //                         executedActions.push(\"like\");\n    //                         elizaLogger.log(`Liked tweet ${tweet.id}`);\n    //                     } catch (error) {\n    //                         elizaLogger.error(\n    //                             `Error liking tweet ${tweet.id}:`,\n    //                             error\n    //                         );\n    //                     }\n    //                 }\n    //             }\n\n    //             if (actionResponse.retweet) {\n    //                 if (this.isDryRun) {\n    //                     elizaLogger.info(\n    //                         `Dry run: would have retweeted tweet ${tweet.id}`\n    //                     );\n    //                     executedActions.push(\"retweet (dry run)\");\n    //                 } else {\n    //                     try {\n    //                         await this.client.twitterClient.retweet(tweet.id);\n    //                         executedActions.push(\"retweet\");\n    //                         elizaLogger.log(`Retweeted tweet ${tweet.id}`);\n    //                     } catch (error) {\n    //                         elizaLogger.error(\n    //                             `Error retweeting tweet ${tweet.id}:`,\n    //                             error\n    //                         );\n    //                     }\n    //                 }\n    //             }\n\n    //             if (actionResponse.quote) {\n    //                 try {\n    //                     // Build conversation thread for context\n    //                     const thread = await buildConversationThread(\n    //                         tweet,\n    //                         this.client\n    //                     );\n    //                     const formattedConversation = thread\n    //                         .map(\n    //                             (t) =>\n    //                                 `@${t.username} (${new Date(\n    //                                     t.timestamp * 1000\n    //                                 ).toLocaleString()}): ${t.text}`\n    //                         )\n    //                         .join(\"\\n\\n\");\n\n    //                     // Generate image descriptions if present\n    //                     const imageDescriptions = [];\n    //                     if (tweet.photos?.length > 0) {\n    //                         elizaLogger.log(\n    //                             \"Processing images in tweet for context\"\n    //                         );\n    //                         for (const photo of tweet.photos) {\n    //                             const description = await this.runtime\n    //                                 .getService<IImageDescriptionService>(\n    //                                     ServiceType.IMAGE_DESCRIPTION\n    //                                 )\n    //                                 .describeImage(photo.url);\n    //                             imageDescriptions.push(description);\n    //                         }\n    //                     }\n\n    //                     // Handle quoted tweet if present\n    //                     let quotedContent = \"\";\n    //                     if (tweet.quotedStatusId) {\n    //                         try {\n    //                             const quotedTweet =\n    //                                 await this.client.twitterClient.getTweet(\n    //                                     tweet.quotedStatusId\n    //                                 );\n    //                             if (quotedTweet) {\n    //                                 quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n    //                             }\n    //                         } catch (error) {\n    //                             elizaLogger.error(\n    //                                 \"Error fetching quoted tweet:\",\n    //                                 error\n    //                             );\n    //                         }\n    //                     }\n\n    //                     // Compose rich state with all context\n    //                     const enrichedState = await this.runtime.composeState(\n    //                         {\n    //                             userId: this.runtime.agentId,\n    //                             roomId: stringToUuid(\n    //                                 tweet.conversationId +\n    //                                     \"-\" +\n    //                                     this.runtime.agentId\n    //                             ),\n    //                             agentId: this.runtime.agentId,\n    //                             content: {\n    //                                 text: tweet.text,\n    //                                 action: \"QUOTE\",\n    //                             },\n    //                         },\n    //                         {\n    //                             twitterUserName: this.client.profile.username,\n    //                             currentPost: `From @${tweet.username}: ${tweet.text}`,\n    //                             formattedConversation,\n    //                             imageContext:\n    //                                 imageDescriptions.length > 0\n    //                                     ? `\\nImages in Tweet:\\n${imageDescriptions\n    //                                           .map(\n    //                                               (desc, i) =>\n    //                                                   `Image ${i + 1}: ${desc}`\n    //                                           )\n    //                                           .join(\"\\n\")}`\n    //                                     : \"\",\n    //                             quotedContent,\n    //                         }\n    //                     );\n\n    //                     const quoteContent = await this.generateTweetContent(\n    //                         enrichedState,\n    //                         {\n    //                             template:\n    //                                 this.runtime.character.templates\n    //                                     ?.twitterMessageHandlerTemplate ||\n    //                                 twitterMessageHandlerTemplate,\n    //                         }\n    //                     );\n\n    //                     if (!quoteContent) {\n    //                         elizaLogger.error(\n    //                             \"Failed to generate valid quote tweet content\"\n    //                         );\n    //                         return;\n    //                     }\n\n    //                     elizaLogger.log(\n    //                         \"Generated quote tweet content:\",\n    //                         quoteContent\n    //                     );\n    //                     // Check for dry run mode\n    //                     if (this.isDryRun) {\n    //                         elizaLogger.info(\n    //                             `Dry run: A quote tweet for tweet ID ${tweet.id} would have been posted with the following content: \"${quoteContent}\".`\n    //                         );\n    //                         executedActions.push(\"quote (dry run)\");\n    //                     } else {\n    //                         // Send the tweet through request queue\n    //                         const result = await this.client.requestQueue.add(\n    //                             async () =>\n    //                                 await this.client.twitterClient.sendQuoteTweet(\n    //                                     quoteContent,\n    //                                     tweet.id\n    //                                 )\n    //                         );\n\n    //                         const body = await result.json();\n\n    //                         if (\n    //                             body?.data?.create_tweet?.tweet_results?.result\n    //                         ) {\n    //                             elizaLogger.log(\n    //                                 \"Successfully posted quote tweet\"\n    //                             );\n    //                             executedActions.push(\"quote\");\n\n    //                             // Cache generation context for debugging\n    //                             await this.runtime.cacheManager.set(\n    //                                 `twitter/quote_generation_${tweet.id}.txt`,\n    //                                 `Context:\\n${enrichedState}\\n\\nGenerated Quote:\\n${quoteContent}`\n    //                             );\n    //                         } else {\n    //                             elizaLogger.error(\n    //                                 \"Quote tweet creation failed:\",\n    //                                 body\n    //                             );\n    //                         }\n    //                     }\n    //                 } catch (error) {\n    //                     elizaLogger.error(\n    //                         \"Error in quote tweet generation:\",\n    //                         error\n    //                     );\n    //                 }\n    //             }\n\n    //             if (actionResponse.reply) {\n    //                 try {\n    //                     await this.handleTextOnlyReply(\n    //                         tweet,\n    //                         tweetState,\n    //                         executedActions\n    //                     );\n    //                 } catch (error) {\n    //                     elizaLogger.error(\n    //                         `Error replying to tweet ${tweet.id}:`,\n    //                         error\n    //                     );\n    //                 }\n    //             }\n\n    //             // Add these checks before creating memory\n    //             await this.runtime.ensureRoomExists(roomId);\n    //             await this.runtime.ensureUserExists(\n    //                 stringToUuid(tweet.userId),\n    //                 tweet.username,\n    //                 tweet.name,\n    //                 \"twitter\"\n    //             );\n    //             await this.runtime.ensureParticipantInRoom(\n    //                 this.runtime.agentId,\n    //                 roomId\n    //             );\n\n    //             if (!this.isDryRun) {\n    //                 // Then create the memory\n    //                 await this.runtime.messageManager.createMemory({\n    //                     id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n    //                     userId: stringToUuid(tweet.userId),\n    //                     content: {\n    //                         text: tweet.text,\n    //                         url: tweet.permanentUrl,\n    //                         source: \"twitter\",\n    //                         action: executedActions.join(\",\"),\n    //                     },\n    //                     agentId: this.runtime.agentId,\n    //                     roomId,\n    //                     embedding: getEmbeddingZeroVector(),\n    //                     createdAt: tweet.timestamp * 1000,\n    //                 });\n    //             }\n\n    //             results.push({\n    //                 tweetId: tweet.id,\n    //                 actionResponse: actionResponse,\n    //                 executedActions,\n    //             });\n    //         } catch (error) {\n    //             elizaLogger.error(`Error processing tweet ${tweet.id}:`, error);\n    //             continue;\n    //         }\n    //     }\n\n    //     return results;\n    // }\n\n    // TODO: #TWITTER-V2-008 - Reimplement action processing using Twitter API v2\n    /**\n     * Handles text-only replies to tweets. If isDryRun is true, only logs what would\n     * have been replied without making API calls.\n     */\n    // private async handleTextOnlyReply(\n    //     tweet: Tweet,\n    //     tweetState: any,\n    //     executedActions: string[]\n    // ) {\n    //     try {\n    //         // Build conversation thread for context\n    //         const thread = await buildConversationThread(tweet, this.client);\n    //         const formattedConversation = thread\n    //             .map(\n    //                 (t) =>\n    //                     `@${t.username} (${new Date(\n    //                         t.timestamp * 1000\n    //                     ).toLocaleString()}): ${t.text}`\n    //             )\n    //             .join(\"\\n\\n\");\n\n    //         // Generate image descriptions if present\n    //         const imageDescriptions = [];\n    //         if (tweet.photos?.length > 0) {\n    //             elizaLogger.log(\"Processing images in tweet for context\");\n    //             for (const photo of tweet.photos) {\n    //                 const description = await this.runtime\n    //                     .getService<IImageDescriptionService>(\n    //                         ServiceType.IMAGE_DESCRIPTION\n    //                     )\n    //                     .describeImage(photo.url);\n    //                 imageDescriptions.push(description);\n    //             }\n    //         }\n\n    //         // Handle quoted tweet if present\n    //         let quotedContent = \"\";\n    //         if (tweet.quotedStatusId) {\n    //             try {\n    //                 const quotedTweet =\n    //                     await this.client.twitterClient.getTweet(\n    //                         tweet.quotedStatusId\n    //                     );\n    //                 if (quotedTweet) {\n    //                     quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n    //                 }\n    //             } catch (error) {\n    //                 elizaLogger.error(\"Error fetching quoted tweet:\", error);\n    //             }\n    //         }\n\n    //         // Compose rich state with all context\n    //         const enrichedState = await this.runtime.composeState(\n    //             {\n    //                 userId: this.runtime.agentId,\n    //                 roomId: stringToUuid(\n    //                     tweet.conversationId + \"-\" + this.runtime.agentId\n    //                 ),\n    //                 agentId: this.runtime.agentId,\n    //                 content: { text: tweet.text, action: \"\" },\n    //             },\n    //             {\n    //                 twitterUserName: this.client.profile.username,\n    //                 currentPost: `From @${tweet.username}: ${tweet.text}`,\n    //                 formattedConversation,\n    //                 imageContext:\n    //                     imageDescriptions.length > 0\n    //                         ? `\\nImages in Tweet:\\n${imageDescriptions\n    //                               .map((desc, i) => `Image ${i + 1}: ${desc}`)\n    //                               .join(\"\\n\")}`\n    //                         : \"\",\n    //                 quotedContent,\n    //             }\n    //         );\n\n    //         // Generate and clean the reply content\n    //         const replyText = await this.generateTweetContent(enrichedState, {\n    //             template:\n    //                 this.runtime.character.templates\n    //                     ?.twitterMessageHandlerTemplate ||\n    //                 twitterMessageHandlerTemplate,\n    //         });\n\n    //         if (!replyText) {\n    //             elizaLogger.error(\"Failed to generate valid reply content\");\n    //             return;\n    //         }\n\n    //         if (this.isDryRun) {\n    //             elizaLogger.info(\n    //                 `Dry run: reply to tweet ${tweet.id} would have been: ${replyText}`\n    //             );\n    //             executedActions.push(\"reply (dry run)\");\n    //             return;\n    //         }\n\n    //         elizaLogger.debug(\"Final reply text to be sent:\", replyText);\n\n    //         let result;\n\n    //         if (replyText.length > DEFAULT_MAX_TWEET_LENGTH) {\n    //             result = await this.handleNoteTweet(\n    //                 this.client,\n    //                 replyText,\n    //                 tweet.id\n    //             );\n    //         } else {\n    //             result = await this.sendStandardTweet(\n    //                 this.client,\n    //                 replyText,\n    //                 tweet.id\n    //             );\n    //         }\n\n    //         if (result) {\n    //             elizaLogger.log(\"Successfully posted reply tweet\");\n    //             executedActions.push(\"reply\");\n\n    //             // Cache generation context for debugging\n    //             await this.runtime.cacheManager.set(\n    //                 `twitter/reply_generation_${tweet.id}.txt`,\n    //                 `Context:\\n${enrichedState}\\n\\nGenerated Reply:\\n${replyText}`\n    //             );\n    //         } else {\n    //             elizaLogger.error(\"Tweet reply creation failed\");\n    //         }\n    //     } catch (error) {\n    //         elizaLogger.error(\"Error in handleTextOnlyReply:\", error);\n    //     }\n    // }\n\n    async stop() {\n        this.stopProcessingActions = true;\n    }\n\n    private async sendForApproval(\n        tweetTextForPosting: string,\n        roomId: UUID,\n        rawTweetContent: string\n    ): Promise<string | null> {\n        try {\n            const embed = {\n                title: \"New Tweet Pending Approval\",\n                description: tweetTextForPosting,\n                fields: [\n                    {\n                        name: \"Character\",\n                        value: this.client.profile.username,\n                        inline: true,\n                    },\n                    {\n                        name: \"Length\",\n                        value: tweetTextForPosting.length.toString(),\n                        inline: true,\n                    },\n                ],\n                footer: {\n                    text: \"Reply with '👍' to post or '❌' to discard, This will automatically expire and remove after 24 hours if no response received\",\n                },\n                timestamp: new Date().toISOString(),\n            };\n\n            const channel = await this.discordClientForApproval.channels.fetch(\n                this.discordApprovalChannelId\n            );\n\n            if (!channel || !(channel instanceof TextChannel)) {\n                throw new Error(\"Invalid approval channel\");\n            }\n\n            const message = await channel.send({ embeds: [embed] });\n\n            // Store the pending tweet\n            const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n            const currentPendingTweets =\n                (await this.runtime.cacheManager.get<PendingTweet[]>(\n                    pendingTweetsKey\n                )) || [];\n            // Add new pending tweet\n            currentPendingTweets.push({\n                tweetTextForPosting,\n                roomId,\n                rawTweetContent,\n                discordMessageId: message.id,\n                channelId: this.discordApprovalChannelId,\n                timestamp: Date.now(),\n            });\n\n            // Store updated array\n            await this.runtime.cacheManager.set(\n                pendingTweetsKey,\n                currentPendingTweets\n            );\n\n            return message.id;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error Sending Twitter Post Approval Request:\",\n                error\n            );\n            return null;\n        }\n    }\n\n    private async checkApprovalStatus(\n        discordMessageId: string\n    ): Promise<PendingTweetApprovalStatus> {\n        try {\n            // Fetch message and its replies from Discord\n            const channel = await this.discordClientForApproval.channels.fetch(\n                this.discordApprovalChannelId\n            );\n\n            elizaLogger.log(`channel ${JSON.stringify(channel)}`);\n\n            if (!(channel instanceof TextChannel)) {\n                elizaLogger.error(\"Invalid approval channel\");\n                return \"PENDING\";\n            }\n\n            // Fetch the original message and its replies\n            const message = await channel.messages.fetch(discordMessageId);\n\n            // Look for thumbs up reaction ('👍')\n            const thumbsUpReaction = message.reactions.cache.find(\n                (reaction) => reaction.emoji.name === \"👍\"\n            );\n\n            // Look for reject reaction ('❌')\n            const rejectReaction = message.reactions.cache.find(\n                (reaction) => reaction.emoji.name === \"❌\"\n            );\n\n            // Check if the reaction exists and has reactions\n            if (rejectReaction) {\n                const count = rejectReaction.count;\n                if (count > 0) {\n                    return \"REJECTED\";\n                }\n            }\n\n            // Check if the reaction exists and has reactions\n            if (thumbsUpReaction) {\n                // You might want to check for specific users who can approve\n                // For now, we'll return true if anyone used thumbs up\n                const count = thumbsUpReaction.count;\n                if (count > 0) {\n                    return \"APPROVED\";\n                }\n            }\n\n            return \"PENDING\";\n        } catch (error) {\n            elizaLogger.error(\"Error checking approval status:\", error);\n            return \"PENDING\";\n        }\n    }\n\n    \n    private async cleanupPendingTweet(discordMessageId: string) {\n        const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n        const currentPendingTweets =\n            (await this.runtime.cacheManager.get<PendingTweet[]>(\n                pendingTweetsKey\n            )) || [];\n\n        // Remove the specific tweet\n        const updatedPendingTweets = currentPendingTweets.filter(\n            (tweet) => tweet.discordMessageId !== discordMessageId\n        );\n\n        if (updatedPendingTweets.length === 0) {\n            await this.runtime.cacheManager.delete(pendingTweetsKey);\n        } else {\n            await this.runtime.cacheManager.set(\n                pendingTweetsKey,\n                updatedPendingTweets\n            );\n        }\n    }\n\n    private async handlePendingTweet() {\n        elizaLogger.log(\"Checking Pending Tweets...\");\n        const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n        const pendingTweets =\n            (await this.runtime.cacheManager.get<PendingTweet[]>(\n                pendingTweetsKey\n            )) || [];\n\n        for (const pendingTweet of pendingTweets) {\n            // Check if tweet is older than 24 hours\n            const isExpired =\n                Date.now() - pendingTweet.timestamp > 24 * 60 * 60 * 1000;\n\n            if (isExpired) {\n                elizaLogger.log(\"Pending tweet expired, cleaning up\");\n\n                // Notify on Discord about expiration\n                try {\n                    const channel =\n                        await this.discordClientForApproval.channels.fetch(\n                            pendingTweet.channelId\n                        );\n                    if (channel instanceof TextChannel) {\n                        const originalMessage = await channel.messages.fetch(\n                            pendingTweet.discordMessageId\n                        );\n                        await originalMessage.reply(\n                            \"This tweet approval request has expired (24h timeout).\"\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error sending expiration notification:\",\n                        error\n                    );\n                }\n\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n                return;\n            }\n\n            // Check approval status\n            elizaLogger.log(\"Checking approval status...\");\n            const approvalStatus: PendingTweetApprovalStatus =\n                await this.checkApprovalStatus(pendingTweet.discordMessageId);\n\n            if (approvalStatus === \"APPROVED\") {\n                elizaLogger.log(\"Tweet Approved, Posting\");\n                await this.postTweet(\n                    this.runtime,\n                    this.client,\n                    pendingTweet.tweetTextForPosting,\n                    pendingTweet.roomId,\n                    pendingTweet.rawTweetContent,\n                    this.client.profile.username\n                );\n\n                // Notify on Discord about posting\n                try {\n                    const channel =\n                        await this.discordClientForApproval.channels.fetch(\n                            pendingTweet.channelId\n                        );\n                    if (channel instanceof TextChannel) {\n                        const originalMessage = await channel.messages.fetch(\n                            pendingTweet.discordMessageId\n                        );\n                        await originalMessage.reply(\n                            \"Tweet has been posted successfully! ✅\"\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error sending post notification:\",\n                        error\n                    );\n                }\n\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n            } else if (approvalStatus === \"REJECTED\") {\n                elizaLogger.log(\"Tweet Rejected, Cleaning Up\");\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n                // Notify about Rejection of Tweet\n                try {\n                    const channel =\n                        await this.discordClientForApproval.channels.fetch(\n                            pendingTweet.channelId\n                        );\n                    if (channel instanceof TextChannel) {\n                        const originalMessage = await channel.messages.fetch(\n                            pendingTweet.discordMessageId\n                        );\n                        await originalMessage.reply(\n                            \"Tweet has been rejected! ❌\"\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error sending rejection notification:\",\n                        error\n                    );\n                }\n            }\n        }\n    }\n}","import { TwitterClientInterface } from \"./client\";\n\nconst twitterPlugin = {\n    name: \"twitter\",\n    description: \"Twitter client\",\n    clients: [TwitterClientInterface],\n};\nexport default twitterPlugin;\n"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoiBA,MAAM,OAAO;AACT,SAAK,wBAAwB;AAAA,EACjC;AAAA,EAEA,MAAc,gBACV,qBACA,QACA,iBACsB;AACtB,QAAI;AACA,YAAM,QAAQ;AAAA,QACV,OAAO;AAAA,QACP,aAAa;AAAA,QACb,QAAQ;AAAA,UACJ;AAAA,YACI,MAAM;AAAA,YACN,OAAO,KAAK,OAAO,QAAQ;AAAA,YAC3B,QAAQ;AAAA,UACZ;AAAA,UACA;AAAA,YACI,MAAM;AAAA,YACN,OAAO,oBAAoB,OAAO,SAAS;AAAA,YAC3C,QAAQ;AAAA,UACZ;AAAA,QACJ;AAAA,QACA,QAAQ;AAAA,UACJ,MAAM;AAAA,QACV;AAAA,QACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MACtC;AAEA,YAAM,UAAU,MAAM,KAAK,yBAAyB,SAAS;AAAA,QACzD,KAAK;AAAA,MACT;AAEA,UAAI,CAAC,WAAW,EAAE,mBAAmB,cAAc;AAC/C,cAAM,IAAI,MAAM,0BAA0B;AAAA,MAC9C;AAEA,YAAM,UAAU,MAAM,QAAQ,KAAK,EAAE,QAAQ,CAAC,KAAK,EAAE,CAAC;AAGtD,YAAM,mBAAmB,WAAW,KAAK,OAAO,QAAQ,QAAQ;AAChE,YAAM,uBACD,MAAM,KAAK,QAAQ,aAAa;AAAA,QAC7B;AAAA,MACJ,KAAM,CAAC;AAEX,2BAAqB,KAAK;AAAA,QACtB;AAAA,QACA;AAAA,QACA;AAAA,QACA,kBAAkB,QAAQ;AAAA,QAC1B,WAAW,KAAK;AAAA,QAChB,WAAW,KAAK,IAAI;AAAA,MACxB,CAAC;AAGD,YAAM,KAAK,QAAQ,aAAa;AAAA,QAC5B;AAAA,QACA;AAAA,MACJ;AAEA,aAAO,QAAQ;AAAA,IACnB,SAAS,OAAO;AACZ,MAAAN,aAAY;AAAA,QACR;AAAA,QACA;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,MAAc,oBACV,kBACmC;AACnC,QAAI;AAEA,YAAM,UAAU,MAAM,KAAK,yBAAyB,SAAS;AAAA,QACzD,KAAK;AAAA,MACT;AAEA,MAAAA,aAAY,IAAI,WAAW,KAAK,UAAU,OAAO,CAAC,EAAE;AAEpD,UAAI,EAAE,mBAAmB,cAAc;AACnC,QAAAA,aAAY,MAAM,0BAA0B;AAC5C,eAAO;AAAA,MACX;AAGA,YAAM,UAAU,MAAM,QAAQ,SAAS,MAAM,gBAAgB;AAG7D,YAAM,mBAAmB,QAAQ,UAAU,MAAM;AAAA,QAC7C,CAAC,aAAa,SAAS,MAAM,SAAS;AAAA,MAC1C;AAGA,YAAM,iBAAiB,QAAQ,UAAU,MAAM;AAAA,QAC3C,CAAC,aAAa,SAAS,MAAM,SAAS;AAAA,MAC1C;AAGA,UAAI,gBAAgB;AAChB,cAAM,QAAQ,eAAe;AAC7B,YAAI,QAAQ,GAAG;AACX,iBAAO;AAAA,QACX;AAAA,MACJ;AAGA,UAAI,kBAAkB;AAGlB,cAAM,QAAQ,iBAAiB;AAC/B,YAAI,QAAQ,GAAG;AACX,iBAAO;AAAA,QACX;AAAA,MACJ;AAEA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,mCAAmC,KAAK;AAC1D,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAGA,MAAc,oBAAoB,kBAA0B;AACxD,UAAM,mBAAmB,WAAW,KAAK,OAAO,QAAQ,QAAQ;AAChE,UAAM,uBACD,MAAM,KAAK,QAAQ,aAAa;AAAA,MAC7B;AAAA,IACJ,KAAM,CAAC;AAGX,UAAM,uBAAuB,qBAAqB;AAAA,MAC9C,CAAC,UAAU,MAAM,qBAAqB;AAAA,IAC1C;AAEA,QAAI,qBAAqB,WAAW,GAAG;AACnC,YAAM,KAAK,QAAQ,aAAa,OAAO,gBAAgB;AAAA,IAC3D,OAAO;AACH,YAAM,KAAK,QAAQ,aAAa;AAAA,QAC5B;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAc,qBAAqB;AAC/B,IAAAA,aAAY,IAAI,4BAA4B;AAC5C,UAAM,mBAAmB,WAAW,KAAK,OAAO,QAAQ,QAAQ;AAChE,UAAM,gBACD,MAAM,KAAK,QAAQ,aAAa;AAAA,MAC7B;AAAA,IACJ,KAAM,CAAC;AAEX,eAAW,gBAAgB,eAAe;AAEtC,YAAM,YACF,KAAK,IAAI,IAAI,aAAa,YAAY,KAAK,KAAK,KAAK;AAEzD,UAAI,WAAW;AACX,QAAAA,aAAY,IAAI,oCAAoC;AAGpD,YAAI;AACA,gBAAM,UACF,MAAM,KAAK,yBAAyB,SAAS;AAAA,YACzC,aAAa;AAAA,UACjB;AACJ,cAAI,mBAAmB,aAAa;AAChC,kBAAM,kBAAkB,MAAM,QAAQ,SAAS;AAAA,cAC3C,aAAa;AAAA,YACjB;AACA,kBAAM,gBAAgB;AAAA,cAClB;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,SAAS,OAAO;AACZ,UAAAA,aAAY;AAAA,YACR;AAAA,YACA;AAAA,UACJ;AAAA,QACJ;AAEA,cAAM,KAAK,oBAAoB,aAAa,gBAAgB;AAC5D;AAAA,MACJ;AAGA,MAAAA,aAAY,IAAI,6BAA6B;AAC7C,YAAM,iBACF,MAAM,KAAK,oBAAoB,aAAa,gBAAgB;AAEhE,UAAI,mBAAmB,YAAY;AAC/B,QAAAA,aAAY,IAAI,yBAAyB;AACzC,cAAM,KAAK;AAAA,UACP,KAAK;AAAA,UACL,KAAK;AAAA,UACL,aAAa;AAAA,UACb,aAAa;AAAA,UACb,aAAa;AAAA,UACb,KAAK,OAAO,QAAQ;AAAA,QACxB;AAGA,YAAI;AACA,gBAAM,UACF,MAAM,KAAK,yBAAyB,SAAS;AAAA,YACzC,aAAa;AAAA,UACjB;AACJ,cAAI,mBAAmB,aAAa;AAChC,kBAAM,kBAAkB,MAAM,QAAQ,SAAS;AAAA,cAC3C,aAAa;AAAA,YACjB;AACA,kBAAM,gBAAgB;AAAA,cAClB;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,SAAS,OAAO;AACZ,UAAAA,aAAY;AAAA,YACR;AAAA,YACA;AAAA,UACJ;AAAA,QACJ;AAEA,cAAM,KAAK,oBAAoB,aAAa,gBAAgB;AAAA,MAChE,WAAW,mBAAmB,YAAY;AACtC,QAAAA,aAAY,IAAI,6BAA6B;AAC7C,cAAM,KAAK,oBAAoB,aAAa,gBAAgB;AAE5D,YAAI;AACA,gBAAM,UACF,MAAM,KAAK,yBAAyB,SAAS;AAAA,YACzC,aAAa;AAAA,UACjB;AACJ,cAAI,mBAAmB,aAAa;AAChC,kBAAM,kBAAkB,MAAM,QAAQ,SAAS;AAAA,cAC3C,aAAa;AAAA,YACjB;AACA,kBAAM,gBAAgB;AAAA,cAClB;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,SAAS,OAAO;AACZ,UAAAA,aAAY;AAAA,YACR;AAAA,YACA;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AL/9CA,IAAM,iBAAN,MAAqB;AAAA,EACjB;AAAA,EACA;AAAA;AAAA,EAEA;AAAA;AAAA,EAGA,YAAY,SAAwB,eAA8B;AAE9D,SAAK,SAAS,IAAI,WAAW,SAAS,aAAa;AAGnD,SAAK,OAAO,IAAI,kBAAkB,KAAK,QAAQ,OAAO;AAStD,SAAK,cAAc,IAAI,yBAAyB,KAAK,QAAQ,OAAO;AAAA,EAOxE;AAAA,EAEA,MAAM,OAAO;AACT,IAAAO,aAAY,KAAK,8CAA8C;AAAA,EACnE;AACJ;AAEO,IAAM,yBAAiC;AAAA,EAC1C,MAAM;AAAA,EACN,MAAM,MAAM,SAAwB;AAChC,UAAM,gBACF,MAAM,sBAAsB,OAAO;AAEvC,IAAAA,aAAY,IAAI,wBAAwB;AAExC,UAAM,UAAU,IAAI,eAAe,SAAS,aAAa;AAGzD,UAAM,QAAQ,OAAO,KAAK;AAG1B,UAAM,QAAQ,KAAK,MAAM;AASzB,UAAM,QAAQ,YAAY,MAAM;AAQhC,WAAO;AAAA,EACX;AACJ;;;AMlFA,IAAM,gBAAgB;AAAA,EAClB,MAAM;AAAA,EACN,aAAa;AAAA,EACb,SAAS,CAAC,sBAAsB;AACpC;AACA,IAAO,gBAAQ;","names":["elizaLogger","getEmbeddingZeroVector","elizaLogger","stringToUuid","elizaLogger","existingMemories","stringToUuid","existingMemoryIds","tweetsToSave","getEmbeddingZeroVector","ActionTimelineType","stringToUuid","elizaLogger","getEmbeddingZeroVector","elizaLogger","stringToUuid","tweet","message","response","tweetId","getEmbeddingZeroVector","TwitterV2IncludesHelper","composeContext","getEmbeddingZeroVector","ModelClass","stringToUuid","elizaLogger","elizaLogger","stringToUuid","getEmbeddingZeroVector","TwitterV2IncludesHelper","composeContext","ModelClass","truncateContent","elizaLogger"]}